\chapter{Introduction}
\label{chapter:Introduction}

Since Android 3.1, which was originally designed for tablet computers, a lot of Android devices come with USB host support (USB On the go). That means a normal Android tablet or phone can not only act as an USB client when connected to a computer. It can also act as an USB host for peripherals by powering the bus with the needed 5 Volt and changing into USB host mode which enables enumeration of connected USB devices\cite{android_usb_host}. Android currently supports interrupt, bulk and control transfers\footnote{Isochronous transfers are currently unsupported\cite{android_usb_constants}.}. That means nearly every USB device can, theoretically, be used with an Android device\footnote{Webcams or Audio devices mostly use isochronous transfers and can thus not be used at the moment.}. The Android host API easily allows to communicate with connected USB devices, ie. a high level USB driver can be written in Java.

Whereby the idea of connecting a USB mass storage device like USB flash drives or external HDDs is not far-fetched. Especially when looking at recent occurrences where a lot of devices miss a slot for SD-Cards and only offer a solid, mostly small, internal storage. Unfortunately the stock Android comes without support for USB storage devices. That means when connecting mass storage devices to an Android phone, nothing happens. The data cannot be accessed via a file manager or something similar. On rooted devices this is possible because the alternative Android ROMs often provide support for it. But with the Android USB Host API it should also be possible to access such devices without rooting the device and flashing an alternative ROM. The only thing needed is to implement the low level USB communication via eg. bulk transfers and the abstraction of directories and files via a file system.

Currently there are two applications in the Google Play Store which allow accessing mass storage devices without root rights! First there is a plugin for the Total Commander called \textit{USB-Stick Plugin-TC}. The plugin extends the Total Commander application by USB mass storage access. It currently supports FAT12, FAT16, FAT32 exFAT and NTFS (read only). There is a free trial version available. The second application is called \textit{Nexus Media Importer}. It supports FAT16, FAT32 and NTFS (also read only). There is no free trial version available. In general both apps support USB sticks, external HDDs and card readers.

The disadvantage both applications have is that there is no solution to access the mass storage from other apps. That means all accessed data has to be cached and copied to the internal storage before any other app can use it. Unfortunately it seems that these limitations are impossible be overcome!

Both applications are proprietary and thus do not offer the ability to look into and change the source code. Therefore an open source Android Framework for accessing mass storage devices is developed in this bachelor thesis. The license is the very liberal Apache License, Version 2.0, like Android is licensed under.

Due to the same licensing it would be possible that Google integrates this solution into the official Android. Indeed there are some disadvantages which make the integration unlikely. First of all, necessary things, like file systems (eg. FAT32) or the SCSI transparent command set, for mounting USB mass storage are already implemented in the underlying Linux kernel. Google just deactivated the support for it. Next, with the solution described in this thesis, only apps which use the framework can access USB storage devices. It would be much nicer if the connected devices would be mounted in the normal unix file system like SD-cards. For example under \textit{/mnt/usbstick0}. This would make it possible for other apps to easily access data from USB mass storage without extra changes to the application. Due to these reasons in my opinion, it is very unlikely that Google will integrate this framework into the official Android. If they want to support mounting USB mass storage devices, they will enable support for it in the kernel and mount the devices in the normal file system, like some manufacturers (eg. Samsung) already do.

Another reason for Google to not implement the support for mass storage devices over USB, is to move more people to use their own cloud service Google Drive. But maybe, if Google notices the growing popularity of applications which allow accessing USB mass storage, Google enables support for it in their mobile operating system.

\subsubsection{Numbers in this thesis}

There are a lot of numbers in this thesis. If the number has a trailing 'h', for example 08h, this number shall be interpreted as a hex number. Numbers without this 'h' shall be interpreted as decimal numbers.

\chapter{Basics about USB}

USB means Universal Serial Bus and is a standard for a serial bus system, for connecting multiple peripheral devices to a personal computer. The first version was introduced by Intel in 1996 and now the specification is done by the USB Implementers Forum (USB-IF). The USB-IF is a corporation founded by various companies which work non-profit on the USB specification. In USB commutation there is one device one called USB host controller (eg. computer) which initiates the connection and communication and multiple clients (slaves). The client only sends data when the host asks for it. The USB host is responsible for powering the connected client, thus an external power source is only necessary in some special cases\cite{wiki_usb}.

\section{Client device hierarchy}

A USB client is structured into four different USB descriptors:

\begin{itemize}
\item Device descriptor
\item Configuration descriptor
\item Interface descriptor
\item Endpoint descriptor
\end{itemize}

The device descriptor represents the USB device as a whole device which is connected to the USB bus. This can, for example be a loud speaker with volume control buttons.\\
The configuration descriptor represents the current state of the USB device. This can for example be standby or active.\\
A USB Interface descriptor describes every logical device which belongs to the USB device. Often USB devices consist of multiple logical device units. For example a loud speaker could consist of the speakers as a audio device and buttons to control the volume as a human interface device. \\
Lastly there are the endpoint descriptors which represent unidirectional communication pipes. This is where the actual communication happens. Endpoints can either be of type IN (device to host) or OUT (host to device). Additional there are four different types of endpoints, to fit the different requirements of communication\cite{free_usb}.\\

\section{Endpoints}

Every USB device has different requirements towards the underlying communication pipe. To satisfy the different needs the USB protocol offers four different types of communication (endpoints).

Control endpoints are used to configure the device and retrieve status information. These transfers are typically very small. Every device has a control endpoint called endpoint 0 which plays an important role at insertion time\cite{free_usb}.

Interrupt transfers carry a small amount of data to the host every time the host asks for it. This happens at a fixed rate resulting in a fixed and guaranteed bandwidth. These transfers are used by Human interface devices (eg. mouse, keyboard, gamepads) which need a low latency and a low packet size.

Next there are bulk endpoints. These are useful when the amount of data transferred varies often and happens infrequently. The remaining available bandwidth the bus offers is used. Hence there is no guarantee on bandwidth or latency. However bulk transfers offer consistent data transfers, meaning that no data is lost. They are typically used for printers, network or mass storage devices. Everywhere where data loss is unacceptable and no guaranteed bandwidth is needed.

Finally there are the isochronous transfers. They offer a guaranteed bandwidth while resigning consistency. The guaranteed bandwidth is mostly as fast as possible and valuable for real time transfers (eg. audio or video). Mostly these transfers are used for Webcams or Audio devices (eg. external audio cards/audio interfaces)\cite{free_usb}.

\section{USB on the go}

As already mentioned, in USB communication there is always a host (master) and a client (device). The host initiates the communication and acts as a master. That means the client is not allowed to send data at any time, it can send data only when the host explicitly asks to do so! The client is only able to signal that it requires attention. Then the host must react and ask for receiving data. When connecting a smartphone or tablet to the computer the computer acts as the host and the smartphone as the client device. That means the smartphone normally acts as a client device and not as the USB host. The host is responsible for the power supply of the client device. In the desired constellation described in this thesis, however, it has obviously to act as a host. 

For that reason the USB-IF developed the USB On the go (USB OTG) feature in 2001. It is part of the USB 2.0 specification\cite{wiki_usb}. This feature allows a USB device to act as a client or either a host depending on the present situation. To use the USB OTG mode, on a smartphone, a special USB OTG adapter is needed. This is necessary for two reasons. A priori for signaling that the smartphone should now act as a host and not as usual as a client and secondly because most smartphones and tables do not provide a normal USB port of type A. Instead they offer a mini (older devices) or micro port of type Mini-A or Micro-B\cite{wiki_usb_otg}. 

\chapter{USB on Android}
\label{chapter:usb_on_android}

As already mentioned with Android 3.1 Honeycomb Google added USB features to the Android OS. There are two different modes Android keeps under control. The already mentioned Host support and a special USB Accessory mode. The Accessory Mode is special and only available on Android. It is supposed to develop USB host hardware specifically designed for Android devices, where the accessory is the USB host and powers the Android device\cite{android_usb_accessory}. The Android device is the client and can for example charge itself and interact with the hardware (eg. playing music through external speakers). 

The USB Accessory mode is also backported to Android 2.3.4\cite{android_usb_accessory}. The developed framework solely relies on the USB host functionality since a memory stick is a USB client.

\section{USB Host API}

On Android there exist classes to enumerate, connect to and communicate with connected USB devices. Table \ref{table:host_api} gives an overview of the classes which can be found in the package \textit{android.hardware.usb}.

\begin{table}[ht]
\caption{USB host APIs \cite{android_usb_host}}
\centering
\begin{tabular}{|l|p{10cm}|}
\hline\hline
\textbf{Class} & \textbf{Description} \\ \hline
UsbManager & Allows you to enumerate and communicate with connected USB devices. \\ \hline
UsbDevice & Represents a connected USB device and contains methods to access its identifying information, interfaces, and endpoints. \\ \hline
UsbInterface & Represents an interface of a USB device, which defines a set of functionality for the device. A device can have one or more interfaces on which to communicate on. \\ \hline
UsbEndpoint & Represents an interface endpoint, which is a communication channel for this interface. An interface can have one or more endpoints, and usually has input and output endpoints for two-way communication with the device. \\ \hline
UsbDeviceConnection & Represents a connection to the device, which transfers data on endpoints. This class allows you to send data back and forth synchronously or asynchronously. \\ \hline
UsbRequest & Represents an asynchronous request to communicate with a device through a UsbDeviceConnection. \\ \hline
UsbConstants & Defines USB constants that correspond to definitions in linux/usb/ch9.h of the Linux kernel. \\ \hline
\end{tabular}
\label{table:host_api}
\end{table}

The UsbRequest class is only needed when communicating asynchronously\footnote{Asynchronous communication is passed in the implementation.}. The rough procedure of getting in touch with a USB device includes following steps:

\begin{enumerate}
\item Retrieve the desired UsbDevice via the UsbManager
\item Get the appropriate UsbInterface and UsbEndpoint
\item Begin the communication by opening a UsbDeviceConnection via the UsbEndpoint
\end{enumerate}

To understand the following sections fundamental knowledge of Android programming is recommended. Basic things\footnote{Following things, for example, are seen as basic: Activity, Intent, PendingIntent, IntentFiler, Broadcast, BroadcastReceiver.} are not described in detail here. An introduction in Android programming can be found in the official Android developer documentation\footnote{\url{http://developer.android.com}}.

\section{Enumerating devices}

To enumerate through all connected USB devices the singleton UsbManager is used. It allows looping through the device list. The device list is returned by the method getDeviceList() of the UsbManager.

\begin{lstlisting}[caption=Enumerating connected USB devices, label=listing:enumerate]
UsbManager usbManager = (UsbManager) context.getSystemService(Context.USB_SERVICE);
		
for(UsbDevice device : usbManager.getDeviceList().values()) {
	Log.i(TAG, "found usb device: " + device);
}
\end{lstlisting}

Accessing the UsbInterface and the UsbEndpoint is also straight forward. The UsbDevice has a method to get the desired interfaces and the UsbInterface has a method to get the desired endpoints on the other hand. Listing \ref{listing:interface_endpoint} illustrates the process.

\begin{lstlisting}[caption=Accessing UsbInterface and UsbEndpoint, label=listing:interface_endpoint]
UsbManager usbManager = (UsbManager) context.getSystemService(Context.USB_SERVICE);
		
for(UsbDevice device : usbManager.getDeviceList().values()) {
	Log.i(TAG, "found usb device: " + device);
	
	int interfaceCount = device.getInterfaceCount();
	for(int i = 0; i < interfaceCount; i++) {
		UsbInterface usbInterface = device.getInterface(i);
		Log.i(TAG, "found usb interface: " + usbInterface);
		
		int endpointCount = usbInterface.getEndpointCount();
		for(int j = 0; j < endpointCount; j++) {
			UsbEndpoint endpoint = usbInterface.getEndpoint(j);
			Log.i(TAG, "found usb endpoint: " + endpoint);
		}
	}
}
\end{lstlisting}

While looping through the devices, it can easily be checked if any device fits the desired needs. UsbDevice and UsbInterface have methods to get the class, subclass and the protocol of the device, resp. the interface. The UsbEndpoint class has methods to get the type, the direction and other attributes of the corresponding endpoint. The UsbDevice also offers methods to get the vendor and product ID of the connected device.

\section{Requesting permission for communication}
\label{section:request_permission}

After discovering a suitable USB device Android requires the user to accept the communication between an application and the USB device first. To do that the permission to communicate with the USB device has to explicitly be requested. A dialog is shown to the user asking for permission, where the user can click okay or cancel. For that the UsbManager offers a method called requestPermission which takes a UsbDevice and a PendingIntent as parameter. The PendingIntent in this case is a Broadcast which can be received via registering a BroadcastReceiver with a specific IntentFilter.

Listing \ref{listing:permission_broadcast} shows how a BroadcastReceiver, for receiving notifications about the permission, can look like. First the the intent action is validated, this step is only needed if the BroadcastReceiver receives multiple different actions. In this example this is not the case. After that the UsbDevice can be accessed via an extra of the intent. Another extra of the intent is the permission state. If it is granted the extra is true and it is permitted to communicate with the device.

\begin{lstlisting}[caption=Permission BroadcastReceiver \cite{android_usb_host}, label=listing:permission_broadcast]
private static final String ACTION_USB_PERMISSION =
    "com.android.example.USB_PERMISSION";
private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {

    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if(ACTION_USB_PERMISSION.equals(action)) {
            synchronized (this) {
                UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);

                if(intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                    if(device != null){
                      //call method to set up device communication
                   }
                } 
                else {
                    Log.d(TAG, "permission denied for device " + device);
                }
            }
        }
    }
};
\end{lstlisting}

The next step is to register this BroadcastReceiver that it can actually receive broadcasts from the system. This normally happens in the onCreate method of an Activity via the method registerReceiver which takes the BroadcastReceive (mUsbReceiver) and and IntentFilter as a parameter. The IntentFilter uses the ACTION\_USB\_PERMISSION string, declared in Listing \ref{listing:permission_broadcast}, to filter out undesired actions.

\begin{lstlisting}[caption=Register the BroadcastReceiver \cite{android_usb_host}, label=listing:register_broadcast]
IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
registerReceiver(mUsbReceiver, filter);
\end{lstlisting}

The last step consists of requesting the permission with using the UsbManager:

\begin{lstlisting}[caption=Register the BroadcastReceiver \cite{android_usb_host}, label=listing:request_permission]
UsbDevice device;
...
mPermissionIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);
mUsbManager.requestPermission(device, mPermissionIntent);
\end{lstlisting}

\section{Communication}

After succeeding all necessary steps to set up the device, finally, communication is possible. To do so the desired device has to be opened and an UsbDeviceConnection has to be retrieved. The class UsbDeviceConnection offers a method to claim a certain UsbInterface. After that communication is possible via the UsbDeviceConnection. It offers methods like bulkTransfer or controlTransfer.

\begin{lstlisting}[caption=Communicating with a connected device \cite{android_usb_host}, label=listing:communication]
private Byte[] bytes
private static int TIMEOUT = 0;
private boolean forceClaim = true;
...
UsbInterface intf = device.getInterface(0);
UsbEndpoint endpoint = intf.getEndpoint(0);
UsbDeviceConnection connection = mUsbManager.openDevice(device); 
connection.claimInterface(intf, forceClaim);
connection.bulkTransfer(endpoint, bytes, bytes.length, TIMEOUT); //do in another thread
\end{lstlisting}

Listing \ref{listing:communication} above uses, for simplicity reasons, the first interface and endpoint. Normally the endpoint to communicate with should be chosen wisely by examining for example the interface class, or the vendor ID of the device. A control transfer would look like analogous.

\section{Tearing down the communication}

When the communication between the Android application and the USB device is done, it has to be shut down. This is done by releasing the interface and closing the connection. Listing \ref{listing:closing_communication} gives a hint about how to do that.

\begin{lstlisting}[caption=Closing communication, label=listing:closing_communication]
public void close() {
	Log.d(TAG, "close device");
	boolean release = deviceConnection.releaseInterface(usbInterface);
	if(!release) {
		Log.e(TAG, "could not release interface!");
	}
	deviceConnection.close();
}
\end{lstlisting}

\section{Listening to attach and detach events}

Android not only allows enumerating connected devices, an application can also register for attach and detach events of USB devices. The application then gets notified whenever a USB device is (dis)connected to the Android device. There are two different solutions to do that. The first one is via a BroadcastReceiver, the second one via the AndroidManifest.xml file. The second solution has the advantage that the application gets notified even if it has not been started before.

\subsection{Via BroadcastReceiver}

\begin{lstlisting}[caption=Attach and detach notification of USB devices via BroadcastReceivers, label=listing:attach_broadcast]
BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction(); 

      if (UsbManager.ACTION_USB_DEVICE_ATTACHED.equals(action)) {
            UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
            if (device != null) {
                // call your method that sets up and initiates communication with the device
            }
        }

      if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
            UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
            if (device != null) {
                // call your method that cleans up and closes communication with the device
            }
        }
    }
};
\end{lstlisting}

To use this BroadcastReceiver register it in your Activity or Service with the corresponding IntentFilter like this:

\begin{lstlisting}[caption=Register the BroadcastReceiver with the desired actions, label=listing:attach_register]
IntentFilter filter = new IntentFilter();
filter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);
filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
registerReceiver(mUsbReceiver, filter);
\end{lstlisting}

\subsection{Via AndroidManifest.xml}

If an application wants to get notified about the attachment of an USB device this can also be specified in the AndroidManifest.xml. This has the advantage that the application does has to be started before. In fact it is started when a desired USB device is connected. The user is then asked if he wants to start the application which can handle the attached device. The next benefit is that the step of requesting permission, described in \ref{section:request_permission}, is not required because the user already gave his consent by allowing the application to start.

As a plus a device filter can be specified. It allows the application to get notified only if an appropriate device was attached. Following attributes can be specified\cite{android_usb_host}:

\begin{itemize}
\item Vendor ID
\item Product ID
\item Class
\item Subclass
\item Protocol (device or interface)
\end{itemize}

Here is an example how a device filter could look like:

\lstset{language=XML}
\begin{lstlisting}[caption=Example device filter \cite{android_usb_host}, label=listing:device_filter]
<?xml version="1.0" encoding="utf-8"?>

<resources>
    <usb-device vendor-id="1234" product-id="5678" class="255" subclass="66" protocol="1" />
</resources>
\end{lstlisting}

This resource file should be located at \textit{res/xml/device\_filter.xml} in the project directory\cite{android_usb_host}. The device filter can then be used in the AndroidManifest.xml, like in Listing \ref{listing:manifest}.

\begin{lstlisting}[caption=AndroidManifest.xml \cite{android_usb_host}, label=listing:manifest]
<manifest ...>
    <uses-feature android:name="android.hardware.usb.host" />
    <uses-sdk android:minSdkVersion="12" />
    ...
    <application>
        <activity ...>
            ...
            <intent-filter>
                <action android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" />
            </intent-filter>

            <meta-data android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED"
                android:resource="@xml/device_filter" />
        </activity>
    </application>
</manifest>
\end{lstlisting}

The intent filter for the action uses, again, the USB\_DEVICE\_ATTACHED string, like when using a BroadcastReceiver. But note that this time no broadcast is sent, an activity is started. The manifest also contains a \textit{uses-feature} entry, because not all Android devices guarantee to support the USB host feature\cite{android_usb_host}. The minimum sdk version is set to 12 here, because on lower API levels the USB API is not available. \\\\
After that the UsbDevice can be accessed anywhere within the Activity like this:

\lstset{language=Java}
\begin{lstlisting}[caption={Accessing the UsbDevice in the Activity, compare to: \cite{android_usb_host}}, label=listing:access_usb_dev_activity]
UsbDevice device = (UsbDevice) getIntent().getParcelableExtra(UsbManager.EXTRA_DEVICE);
\end{lstlisting}

\chapter{USB Mass storage class}

Most USB devices of same type. To reduce development effort and allow OS designers offering generic drivers for a great range of different devices a lot of device types are standardized. These different types are called classes in USB. There are for example standardizations for printers, USB hubs, Audio or Video Devices, Human Interface devices and mass storage devices\cite{usb_classes}. The focus now, is on the mass storage class.

Every mass storage device has at least one interface descriptor with the class code 08h, which stands for the mass storage class. Note that the mass storage class is not defined in the device descriptor! The USB interface has exactly two endpoint descriptors. One IN endpoint to read from the device and one OUT endpoint to write to the device\cite{usb_ms_jan}. Reading and writing in this case does not necessarily mean reading or writing on the actual storage medium, but this is described later.

There are two different types regarding the mass storage class. There is the bulk-only transport (BBB) mechanism which is the most popular one. All newer devices follow that standard. Then there is the Control/Bulk/Interrupt (CBI) standard which is no longer important, because the USB-IF recommends using the BBB approach\cite{usb_ms_jan}.

\section{Bulk-only Transport}

Unlike the name suggests there are two control requests in the BBB specification. The first one is a reset request to make the device becoming ready for the next command. The second is used to get the maximum LUN (Get Max LUN request). This requests tells about the number of standalone logical units the mass storage device supports\cite{usb_ms_jan}.

Like said before the interface class has to be set to 08h for the mass storage class. The subclass of the interface descriptor can have different values and specifies the supported protocols used to read and write data to the mass storage. Table \ref{table:subclass} gives an overview of the different protocols.

\begin{table}[ht]
\caption{Overview subclass protocols \cite{usb_ms_jan}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
01h & Reduced Block Commands (RBC) \\ \hline
02h & SFF-8020i, MMC-2 (ATAPI) (CD/DVD drives) \\ \hline
03h & QIC-157 (tape drives) \\ \hline
04h & USB Floppy Interface (UFI) \\ \hline
05h & FF-8070i (ATAPI removable rewritable media devices) \\ \hline
06h & SCSI transparent command set \\ \hline
\end{tabular}
\label{table:subclass}
\end{table}

For the purpose described in this thesis, the SCSI transparent command set is the most important one, which is explained in the following chapter. The RBC is not even implemented in Windows, but in the Linux kernel\cite{usb_ms_jan}. The other protocols refer to other types of storage media and not covered by this thesis.

\section{SCSI transparent command set}

Every SCSI command the host sends to the client is enclosed by a so called Command Block Wrapper (CBW). Sending this CBW is always the first thing when host and device exchange data. After transmitting the CBW, raw data can be transferred. The direction of that data can either be from the host to the device or vice versa. In this document, from now on, this phase is called the transport or transfer phase. Some commands do not need the data transfer phase. In the last step the client device sends a Command Status Wrapper (CSW) to the host to inform about any failures or success.

The CBW is always 31 bytes long including the enclosing SCSI command. The host sends it through the OUT endpoint to the device. Following table illustrates the CBW:

\begin{table}[ht]
\caption{Command Block Wrapper, compare to: \cite{usb_ms_jan}}
\centering
\begin{tabular}{|l|l|p{9cm}|}
\hline\hline
\textbf{Field Name} & \textbf{Bits} & \textbf{Description}\\ \hline
dCBWSignature & 32 & Fixed value of 43425355h to identify the CBW. \\ \hline
dCBWTag & 32 & Corresponds to dCSWTag in CSW. \\ \hline
dCBWDataTransferLength & 32 & The number of bytes which will be sent by the host in the transfer phase or the number of bytes the host expects to receive in the transfer phase. Depends on bmCBWFlags. \\ \hline
bmCBWFlags & 8 & If bit 7 is set to 0 the data transfer is from host to device, if it is set to 1 from device to host. All other bits are unused. If there is no transfer phase this value shall be zero. \\ \hline
Reserved & 4 & - \\ \hline
bCBWLUN & 4 & The LUN the command is directed to. \\ \hline
Reserved & 3 & - \\ \hline
bCBWCBLength & 5 & The length of the actual SCSI command located in the CBWCB field. \\ \hline
CBWCB & 128 & The SCSI command the client shall execute. \\ \hline
\end{tabular}
\label{table:cbw}
\end{table}

The dCBWTag is useful to associate the CSW with the CBW. The device uses the same value stored in the dCBWTag in the dCSWTag of the CSW. If multiple CBWs are sent at the same time the corresponding CSWs can be easily found with the help of the tag.
\\\\
What data is transferred and how, is discussed in the sections about the different SCSI commands. For now it is ignored and the CSW is introduced in table \ref{table:csw}. The CSW is always 13 bytes.

\begin{table}[ht]
\caption{Command Status Wrapper \cite{usb_ms_jan}}
\centering
\begin{tabular}{|l|l|p{9cm}|}
\hline\hline
\textbf{Field Name} & \textbf{Bits} & \textbf{Description}\\ \hline
dCSWSignature & 32 & Fixed value of 53425355h to identify the CSW. \\ \hline
dCSWTag & 32 & Value of dCBWTag from the sent CBW. \\ \hline
dCSWDataResidue & 32 & This indicates the number bytes in the transport phase the device has not yet processed. Should be 0 if all data has been processed. \\ \hline
bCSWStatus & 8 & 0 if command successfully passed, 1 if there was an error and 2 on a phase error. \\ \hline
\end{tabular}
\label{table:csw}
\end{table}

\newpage

The dCSWDataResidue holds the difference between the dCBWDataTransferLength and the number of bytes the device either processed when the host sends data or the number of bytes the device already sent to the host. Mostly all data can be transferred in one transfer phase meaning dCSWDataResidue is mostly zero.

The bCSWStatus informs about the success of executing the desired SCSI command. A value of zero indicates success. If this field is set to one there was an error executing the command. The host should then issue a SCSI REQUEST SENSE command to get more information about what went wrong\cite{usb_ms_jan}. More on this SCSI command later. If this value is two the host should perform a reset recovery. The reset consists of a bulk-only mass storage reset, which is one of the class specific commands and a Clear Feature HALT on the IN and OUT endpoint\cite{usb_ms_jan, usb_mass_bulk}.
\\\\
The fields in the CBW and CSW are all serialized in little endian style.

\section{SCSI Commands}
\label{section:scsi_commands}

The Small Computer System Interface (SCSI) is a standard for communicating between computers and peripheral devices. It is most commonly used for hard disks and other storage devices, but it can also used for example for scanners\cite{wiki_scsi}. SCSI commands are used to get general information about the connected storage device, but also for reading and writing data from and to the device's storage. The USB mass storage class also uses this well established standard.

The are a lot of different SCSI commands and not every device supports every command. To determine which commands a device supports, the host issues a SCSI INQUIRY command. Every device has to support this command and deliver a meaningful response to it. The device discloses, with the information included in the INQUIRY response, which commands are supported, ie. which standardization it follows. In practice the most common used commands are these\cite{usb_ms_jan}:

\begin{itemize}
\item INQUIRY
\item READ CAPACITY(10)
\item READ(10)
\item REQUEST SENSE
\item TEST UNIT READY
\item WRITE(10)
\end{itemize}

Every device should support at minimum these commands! Every SCSI command starts with the operation code, also called OPCODE (one byte), which identifies the command. The following data then depends on the specific command. The ten after some commands describes the length of the command in bytes. There are for example different READ commands, READ(6), READ(10), READ(12), READ(16) and READ(32)\cite{scsi_seagate}. These commands all differ in their length. This is needed because in the READ(6) command, the logical block address field which is used to address a block is only 16 bit. However devices with a big storage cannot use this command, because the whole storage cannot be addressed with a 16 byte value. Thus in the READ(10) command, which is the most commonly used, the address field is 32 bit.\\\\
SCSI commands use the big endian style for storing fields bigger than one byte.

\subsection{INQUIRY}

As already mentioned the INQUIRY command is used to get general information about the connected storage device. A host should issue this command to determine the supported SCSI commands by the device. The response to the INQUIRY command is transferred in the transport phase between sending the CBW which includes the INQUIRY command and receiving the CSW. The direction of the transport phase is from the client to the host.

\begin{table}[ht]
\caption{INQUIRY command, compare to: \cite{scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation code (12h) \\ \hline
1 & Bit 0: EVPD, Bit 1: Obsolete, Bit 2-7: Reserved\\ \hline
2 & Page Code \\ \hline
3-4 & Allocation Length (Byte 3: MSB, Byte 4: LSB) \\ \hline
5 & Control \\ \hline
\end{tabular}
\label{table:inquiry}
\end{table}

The most important fields in the INQUIRY command are the operation code and the allocation length. The allocation length tells the storage device how many bytes the host has allocated for the INQUIRY response. The device then replies with an answer at most as big as the allocation length. The allocation field should be at least five (bytes). The EVPD\footnote{Enable Vital Product Data} and the page code are used to get more information about the vital product data. If the EVPD bit is set to one, the device should return the part of the vital product data specified in the field page code. If the EVPD bit is set to zero only the standard INQUIRY data shall be returned\cite{scsi_seagate}. This thesis describes only the latter case.

The Allocation Length field and the Control field are commonly used fields which occur in various SCSI commands\cite{scsi_seagate}.

The response to the standard INQUIRY request shall contain 36 bytes\cite{scsi_seagate}. Bytes 5 to N consist of fields not discussed here, because they are less important or vendor specific information.

\begin{table}[ht]
\caption{Standard INQUIRY data, compare to: \cite{usb_ms_jan, scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Bit 0-4: Peripheral device type, Bit 5-7: Peripheral Qualifier \\ \hline
1 & Bit 0-6: Reserved, Bit 7: RMB \\ \hline
2 & Version \\ \hline
3 & Bit 0-3: Response data format, Bit 4: HISUP, Bit 5: NORMACA Bit 6,7: Obsolete \\ \hline
4 & Additional length (N-4) \\ \hline
5-N & ... \\ \hline
\end{tabular}
\label{table:inquiry_data}
\end{table}

The peripheral device type shall always be zero. This indicates that a peripheral device is connected to the logical unit. The peripheral qualifier describes the connected device. If this field is set to zero the connected device is a direct access block device. A value of two means a printer device and a value of five indicates a CD or DVD drive\cite{usb_ms_jan, scsi_seagate}. This value shall also always be zero for a direct access block device, because the direct acess block device is the only type of device the framework shall support.

The RMB bit indicates if the device is removable or not. Zero indicates a non removable device and one a removable device. USB flash drives are removable devices, but they have a fixed media unlike card readers. But Microsoft suggests that flash drives declare they have removable media, and thus some flash drives do this\cite{usb_ms_jan}.

The Version field indicates which standard of the SPC (SCSI Primary commands) the device follows. If the value is zero the device does not comply to any standard. If the value is three or four, the device complies to the SPC or SPC-2 standard\cite{usb_ms_jan, scsi_seagate}.

The Response Data Format field must equal to two, because values lower than two are obsolete and values bigger than two are reserved\cite{scsi_seagate}.

The additional length provides information about how many bytes are remaining in the response. The additional data is not important for us at the moment.

\subsection{TEST UNIT READY}

This command tests if the storage device is ready to use. It does not have a transport phase. If the device is ready to use the CSW status is set to successful and if not to a status indicating failure. In the latter case the host should issue a SCSI REQUEST SENSE, to get information about what went wrong. When the device has removable media, this command can be used to check if a media is currently present\cite{usb_ms_jan}.

\begin{table}[ht]
\caption{TEST UNIT READY command \cite{scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation Code (00h)\\ \hline
1-4 & Reserved \\ \hline
5 & Control \\ \hline
\end{tabular}
\label{table:unit_ready}
\end{table}

\newpage

\subsection{READ CAPACITY}

The READ CAPACITY command is used to determine the storage space of a device. The device tells the host the logical block address (LBA) of the last block and the size in bytes of a single block. The total number of blocks is the LBA of the last block address plus one. The direction of the transport phase is from the peripheral to the computer.

\begin{table}[ht]
\caption{READ CAPACITY(10) command \cite{scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation Code (25h)\\ \hline
1 & Bit 0: Obsolete, Bit 1-7: Reserved \\ \hline
2-5 & Logical Block Address (Byte 2: MSB, Byte 5: LSB) \\ \hline
6,7 & Reserved \\ \hline
8 & Bit 0: PMI, Bit 1-7: Reserved \\ \hline
9 & Control \\ \hline
\end{tabular}
\label{table:read_capacity}
\end{table}

If the PMI (partial media indicator) bit is set to zero, the logical block address also must be set to zero. The device then returns information of the last logical block. If the PMI bit is set to one, the Seagate manual on SCSI commands says: "A PMI bit set to one specifies that the device server return information on the last logical block after that specified in the LOGICAL BLOCK ADDRESS field before a substantial vendor specific delay in data transfer may be encountered."\cite{scsi_seagate}

The response transferred in the transport phase looks like this:

\begin{table}[ht]
\caption{READ CAPACITY(10) response, compare to \cite{usb_ms_jan, scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0-3 & Last Logical Block Address (Byte 0: MSB, Byte 3: LSB)\\ \hline
4-7 & Block length in bytes (Byte 4: MSB, Byte 7: LSB) \\ \hline
\end{tabular}
\label{table:read_capacity_response}
\end{table}

\subsection{READ(10) and WRITE(10)}

The READ(10) command requests the device to read the specified blocks from the storage and to transfer them to the host. The logical block address included in the command specifies the block where reading shall begin. The transfer length field holds the amount of contiguous blocks that shall be read. The device then transmits the requested data in the data transport phase. The device does not have to care about the actual data, it transfers it to the host just like it is saved on the storage. Table \ref{table:read_10} shows how the READ(10) command is constructed.

\begin{table}[ht]
\caption{READ(10) command \cite{scsi_seagate}}
\centering
\begin{tabular}{|l|p{10cm}|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation Code (28h)\\ \hline
1 & Bit 0: Obsolete, Bit 1: FUA\_NV, Bit 2: Reserved, Bit 3: FUA, Bit 4: DPO, Bit 5-7: RDPROTECT \\ \hline
2-5 & Logical Block Address (LBA) (Byte 2: MSB, Byte 5: LSB) \\ \hline
6 & Bit 0-4: Group Number, Bit 5-7: Reserved \\ \hline
7,8 & Transfer Length (Byte 7: MSB, Byte 8: LSB) \\ \hline
9 & Control \\ \hline
\end{tabular}
\label{table:read_10}
\end{table}

For us only the LBA and Transfer Length fields are important. The other fields shall remain zero. They are responsible for example to specify caching behavior or read protection\footnote{Way back, pen drives with a physical switch for write protection, were pretty common.}.

The WRITE(10) command is formatted exactly like the READ(10) command except that the operation code is 2Ah and the RDPROTECT field is called WDPROTECT. The direction of the transport phase is, of course, the other way round, from computer to the device. Remember that the direction has to be specified correctly in the CBW!

\subsubsection{Logical Block Address}

Every mass storage device is structured in blocks. These blocks have a definite size. The size of each block can be determined by issuing a READ CAPACITY(10) command. The blocks are numbered contiguously beginning from zero to the amount of blocks minus one. This number is called logical block address, short LBA. With the LBA every block can easily be addressed and accessed. The READ(10) and WRITE(10) SCSI commands use this method of addressing for reading and writing data to the storage medium. The transfer length specifies how many blocks, including the block at the LBA, shall be transferred. That means reading or writing begins at a block defined through the LBA with as many directly consecutive blocks as desired.

\subsection{REQUEST SENSE}

If the device fails executing a SCSI command requested by the computer, an unsuccessful CSW status is set. The computer then knows that something went wrong, but it does not know what went wrong. To get more information about a specific error the host can issue a REQUEST SENSE command, to request the sense data from the device.

\begin{table}[ht]
\caption{REQUEST SENSE command \cite{scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation Code (03h)\\ \hline
1 & Bit 0: DESC, Bit 1-7: Reserved \\ \hline
2-3 & Reserved \\ \hline
4 & Allocation Length \\ \hline
5 & Control \\ \hline
\end{tabular}
\label{table:request_sense}
\end{table}

\newpage

The DESC bit describes if the fixed sense data or the descriptor format sense data shall be transferred. A value of zero requests the fixed sense data\cite{scsi_seagate}.

The Allocation Length field indicates, like in the INQUIRY command, how many bytes the host has allocated for data to be received. The device does not send more data than the host has actually allocated. But that means that some information can be lost if the data requested is actually bigger than the allocated space.

Table \ref{table:sense_data} shows the contents of the fixed sense data transferred from the device to the computer in the data transport phase. The size of the sense data is normally 252 bytes, with vendor specific information beginning at byte 18.

\begin{table}[ht]
\caption{Standard INQUIRY data, compare to: \cite{usb_ms_jan, scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Bit 0-6: Response Code, Bit 7: VALID \\ \hline
1 & Obsolete \\ \hline
2 & Bit 0-3: SENSE KEY, Bit 4: Reserved, Bit 5: ILI, Bit 6: EOM, Bit 7:  FILEMARK \\ \hline
3-6 & Information (Byte 3: MSB, Byte 6: LSB) \\ \hline
7 & Additional sense length (N-7) \\ \hline
8-11 & Command-specific information (Byte 8: MSB, Byte 11: LSB) \\ \hline
12 & Additional Sense Code \\ \hline
13 & Additional Sense Code Qualifier \\ \hline
14 & Field replaceable unit code \\ \hline
15-17 & Bit 0-20: Sense key Specific, Bit 21: SKSV \\ \hline
18-N & ... \\ \hline
\end{tabular}
\label{table:sense_data}
\end{table}

A detailed description of these fields can be found in the SCSI commands reference manual from Seagate\cite{scsi_seagate}.

\chapter{File systems}

\section{General}

With the USB bulk transfers and the SCSI commands it is now possible to read and write raw data from and to the device. That means one can now access the bytes stored on the medium. The only thing missing is some abstraction to handle the raw data. To do this on mass storage devices the most commonly used approach are partitions and file systems. A file system is an approach to organize data in directories and files and with human readable names. Thus the user can easily find things without knowing something about the addressing methods of a mass storage device.

\subsubsection{Directories}

A directory is a container for files and other directories. With the help of a directory the contents of a file system or mass storage device can easily be structured in a tree based way. Every file system has a root directory which is the directory at the top of the file system.

\subsubsection{Files}

Other than directories, files do not help structuring the contents, but hold the actual data the user wants to save and later access again.

\subsection{Examples}

Today there exist many different file systems. Most important file systems are FAT32 and NTFS from Windows background, ext3, ext4 and btrfs from the Linux/Unix background and HFS+, also called Mac OS Extended, developed by Apple for their OS X operating system. All listed file systems, except FAT32, use binary trees or something related to structure the contents of the directories.

On USB mass storage devices the most popular file systems are FAT32 and NTFS, because obviously most people use the Windows operating system. The NTFS specification is not published by Microsoft. Thus it is very hard to support NTFS on other systems, nevertheless there is NTFS support in the Linux kernel. The FAT32 specification is publicly available and can be downloaded from the Microsoft website\footnote{\url{http://msdn.microsoft.com/en-us/windows/hardware/gg463080.aspx}}. Because of the lack of support for unix like file systems on Windows, the Linux and OS X file systems are only used by someone who do not need to exchange data with Windows machines. Therefore the FAT32 file system, which has an open specification and is very popular on sd cards and pen drives, is introduced in the following sections in detail.

\subsection{Partition Table}

Before having a closer look at the FAT32 file system, partition tables have to be explained. A physical drive can have multiple partitions which operate independent from each other. They can also have different file systems. In Windows for example every partition is handled by a separate drive letter.

A partition table holds the information needed for identifying the different partitions on the disk. This information includes where the partition on the disk starts, ends or how many blocks it occupies and with which file system the partition is formatted. There are two different partition tables most commonly used today. The Master Boot Record (MBR) and the GUID partition table (GPT) which is part of the UEFI standard\cite{wiki_guid}. The Master Boot Record is used in PCs with BIOS and is currently replaced by the GPT in UEFI PCs. On USB mass storage devices mostly the MBR is applicable. 

\subsubsection{The Master Boot Record}

The MBR occupies 512 bytes at the beginning (LBA zero) of the medium. The first 446 bytes can store executable code the BIOS executes when a PC is booting. The executable code is then responsible for booting from an bootable partition. Beginning with byte 446 the partition table starts. There is place for up to four partition table entries. The last two bytes are the boot signature which identify the MBR. Byte 510 must be 55h and byte 511 must be AAh\cite{fat_paul}.

Since there is only place for four partition table entries a disk formatted with the MBR normally could only have up to four different partitions, called primary partitions. If more partitions are required, extended partitions may be used. An extended partition has its own partition table enclosed by an extended boot record (EBR). The partition table entry in the MBR then points to the EBR which is followed by the extended partition. An EBR can contain one additional entry for another extended partition, thus there is theoretically no limit to the number of extended partitions\cite{usb_ms_jan}.

\begin{table}[ht]
\caption{Partition Table Entry in the MBR, compare to: \cite{usb_ms_jan}}
\centering
\begin{tabular}{|l|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Size} & \textbf{Description}\\ \hline
0 & 1 & Boot Indicator, 00h for non bootable partition, 80h for bootable partition \\ \hline
1 & 1 & CHS addressing \\ \hline
2 & 2 & CHS addressing \\ \hline
4 & 1 & Partition Type \\ \hline
5 & 1 & CHS addressing \\ \hline
6 & 2 & CHS addressing \\ \hline
8 & 4 & LBA of the first sector \\ \hline
12 & 4 & Total number of sectors/blocks the partition occupies \\ \hline
\end{tabular}
\label{table:mbr_entry}
\end{table}

The important fields of a partition table entry fields are located at byte four, eight and twelve. The fields for CHS addressing are pretty much obsolete. It is a former way to address the blocks on a block device through cylinder head and sector information. Today only the logical block addressing mechanism is important.

The partition table entry holds the first logical block address of the partition. This is where the partition starts, and the content of the file system of the desired partition begins. The entry also holds the total number of blocks the partition occupies, but mostly this value is also stored in the file system of the partition, and most software uses this value instead\cite{usb_ms_jan}.

The partition type can either be a value indicating which file system the partition has, e.g. 0Bh or 0C for FAT32 or if this entry stands for an extended partition. Extended partitions are identified by values of 05h or 0Fh. If the partition table entry is unused the partition type must equal to zero\cite{usb_ms_jan}.
\\\\
All fields bigger than one byte are stored using little endian style, as in the FAT32 file system.

\subsubsection{Drives without a partition table}

Sometimes drives do not have a partition table. If the device requires only one partition, the partition table is only a waste of space. If devices do not have a partition table, the file system directly begins at LBA zero.

But it is pretty hard to determine if the device has a partition table or if the file system directly starts, thus most devices have a partition table. 

\section{The FAT32 file system}

The FAT32 file system was developed and published in 1996 with Windows 95. FAT means File Allocation Table which is an important part of every FAT32 system, but more on that later. There are two ancestors of the FAT32 file system, FAT12 and FAT16. They vary in the size of an entry in the FAT. The entries of the FAT in a FAT32 file system have the size of 32 bit. Due to the size of 32 bit FAT32 has one big disadvantage. The file size is limited to 4 GiB - 1 Byte, which is sometimes unpleasant in everyday situations\cite{wiki_fat}.

\subsection{General layout}

The general layout of every FAT32 file system consists of following parts\cite{fatgen103, wiki_fat}:

\begin{enumerate}
\item Reserved Region (Boot Sector, FS Information Sector, optional reserved sectors)
\item File Allocation Table
\item Data area (directories and files)
\end{enumerate}

Figure \ref{figure:general_fat32_layout} illustrates the general layout from the beginning of an FAT32 formatted volume to its end. The sector size is assumed to be 512 bytes, which it mostly is. Nevertheless, it can be different from 512 bytes. The sector size can be determined in the boot sector structure at the beginning of the medium. Directly after the reserved region the file allocation tables are located. The last and also the biggest region is the data area. In the data area the actual content like directories and files is saved. Every part is described in detail in the following sections.

\begin{figure}[h!]
\caption{General layout of an FAT32 formatted volume}
\centering
\includegraphics[scale=0.62]{figures/fat_general}
\label{figure:general_fat32_layout}
\end{figure}


\subsubsection{Reserved Region}

The reserved region includes the boot sector and the FS Information sectors. The boot sector holds important information of the FAT32 file system. For example the sector and the cluster size, the start cluster of the root directory and how many FATs exist. The FS Information Sector holds information about the last allocated cluster and the free cluster count. A file system driver can then easier locate a free cluster and give information about the remaining free space on the disk. After that optional reserved sectors can follow, for example a backup of the boot sector and the FS Information Structure\cite{usb_ms_jan}.

\subsubsection{File Allocation Table}

The contents of the FAT32 file system is structured in so called clusters. A cluster has a specific size which is specified in the boot sector. A cluster is the smallest unit which can be allocated in the file system. That means if a file for example has only one bytes of contents but the cluster size is 4096 bytes the file needs 4096 bytes of space. The unneeded 4095 bytes are padded and wasted because they cannot be used for other files.

Every FAT32 file system has a definite amount of clusters which can be used for storing contents. The FAT gives an overview of which clusters are used and which are free. The FAT is a dynamically linked list. Giving a start cluster the FAT can be followed up to the end, identified by an end of chain mark. The resulting cluster chain helps locating the contents on the disk.

\subsubsection{Data area}

The data area holds the actual content, of the file system, the user wants to save. These are directories and files.

\subsection{Boot Sector and FS Information Structure}

\subsubsection{Boot Sector}

At the beginning of every FAT32 file system the boot sector is located. Table \ref{table:fat_boot_sector} shows the contents of the boot sector. The boot sector has the size of one sector (BPB\_BytsPerSec), which is typically 512 byte. Only the fields of interest are shown. A complete overview is given in the official FAT specification from Microsoft\cite{fatgen103}.

\begin{table}[!ht]
\caption{Boot Sector, compare to: \cite{usb_ms_jan, fatgen103}}
\centering
\begin{tabular}{|l|l|l|p{9cm}|}
\hline\hline
\textbf{Name} & \textbf{Offset} & \textbf{Size} & \textbf{Description}\\ \hline
BPB\_BytsPerSec & 11 & 2 & Count of bytes per one single sector. This is mostly 512 bytes, and other allowed values are 1024, 2048 and 4096. A lot of file system drivers assume that this field is 512 and do not check it! \\ \hline
BPB\_SecPerClus & 13 & 1 & Count of sectors per cluster. This value must be a power of two greater than 0 and is mostly 8. The cluster size in bytes can be calculated with BPB\_BytsPerSec * BPB\_SecPerClus. \\ \hline
BPB\_RsvdSecCnt & 14 & 2 & Number of reserved sectors at the beginning of the volume, including the boot sector, preceding the FATs. This value is typically 32. \\ \hline
BPB\_NumFATs & 16 & 1 & The number of FATs in this file system. The FATs can be mirrored to provide redundancy to ensure that there is always a valid FAT which is not corrupt due to bad sectors or something else. This value is typically 2, meaning there are two different FATs holding the same information. \\ \hline
BPB\_TotSec32 & 32 & 4 & The total amount of sectors in the file system. \\ \hline
BPB\_FATSz32 & 36 & 4 & The number of sectors one FAT occupies. \\ \hline
BPB\_ExtFlags & 40 & 2 & Bit 0-3: Zero based number of the valid FAT if mirroring of FATs is disabled. Bit 7: Indicates if FATs are mirrored or not. Zero for mirroring, one if only one FAT is valid. Valid FAT can be determined with Bit 0-3. Other bits are reserved. \\ \hline
BPB\_RootClus & 44 & 4 & The start cluster of the root directory. This is typically cluster 2. \\ \hline
BPB\_FSInfo & 48 & 2 & The sector number of the FS Information Sector in the reserved region. \\ \hline
BPB\_BkBootSec & 50 & 2 & If this value is non zero, it indicates the sector number of the backup boot sector within the reserved region. This valie is typically 6. \\ \hline
BS\_VolLab & 71 & 11 & Human readable string which gives the volume a name. This field is often replaced by a volume label entry in the root directory. \\ \hline
\end{tabular}
\label{table:fat_boot_sector}
\end{table}

The boot sector has the same boot signature at byte 510 and 511 like the MBR. That is another problem why it is problematic determining if the current drive has an MBR or if the file system starts directly.

\newpage

\subsubsection{FS Information Structure}

The FS Information Structure, also called FSInfo Sector Structure in Microsoft documents, helps finding free clusters quickly. Because the FAT can be very big in a FAT32 file system it can take a lot of time to go through the whole FAT to search for a free cluster. For that reason, the FSInfo Structure holds a hint to the last allocated cluster. It also stores the count of free clusters. The location of the sector is stored in the boot sector.

\begin{table}[!ht]
\caption{FSInfo Sector, compare to: \cite{fatgen103}}
\centering
\begin{tabular}{|l|l|l|p{9cm}|}
\hline\hline
\textbf{Name} & \textbf{Offset} & \textbf{Size} & \textbf{Description}\\ \hline
FSI\_LeadSig & 0 & 4 & Fixed value of 41615252h to identify the FSInfo Sector. \\ \hline
FSI\_Reserved1 & 4 & 480 & Reserved and normally set to zero. \\ \hline
FSI\_StrucSig & 484 & 4 & Fixed value of 61417272h to identify the FSInfo Sector. \\ \hline
FSI\_Free\_Count & 488 & 4 & The amount of free clusters in the volume. If FFFFFFFFh the free cluster count is unknown and should be computed. \\ \hline
FSI\_Nxt\_Free & 492 & 4 & The last known allocated cluster in the volume. A file system driver should use this to start searching for the free clusters. This does not mean the cluster after the last known is really free, it is just a hint! If FFFFFFFFh the last allocated cluster hint is unknown and the whole FAT has to be searched. \\ \hline
FSI\_Reserved2 & 496 & 12 & Reserved and normally set to zero. \\ \hline
FSI\_TrailSig & 508 & 4 & Fixed value of AA550000h to identify the FSInfo Sector. \\ \hline
\end{tabular}
\label{table:fat_fs_info}
\end{table}

\subsection{File Allocation Table}

As already mentioned, the File Allocation Table (FAT) is a dynamically linked list with a fixed size. It starts directly after the reserved region. The size of the FAT is stored in the boot sector of the FAT32 file system. The FAT is very important, because it holds the information about which clusters are used and which one not. Moreover it defines which different clusters combined define a file resp. directory. Thus the FAT can be mirrored, for backup reasons. The total count of FATs is located in the boot sector. The next FAT directly begins after the current FAT. Normally on a FAT32 file system there are two FATs holding the same information.

Every entry of the FAT is 32 bit, with the lower 28 bit representing the cluster number. The other four bit are unused. The first two entries in the FAT do not store any information about clusters, the data area begins with cluster 2.

\subsubsection{Cluster chains}

A series of clusters is called a cluster chain. Every directory or file consists of a specific cluster chain defining the location of the contents of the disk. To follow such a chain, a start cluster is needed. The start cluster of the root directory for example is stored in the boot sector. A FAT32 file system then seeks into the FAT where the start cluster is located. In bytes this is 4 * start cluster (Every entry is 32 bit = 4 byte). The value stored at this location is the next cluster in the chain. This is repeated until the value stored is an "end of chain mark". This determines the end of a cluster chain. A value above FFFFFF7h is an end of chain mark. A value of zero indicates that the cluster is free and a value of one that the cluster is reserved. A value of FFFFFF7h stands for a bad cluster.

\begin{figure}[h!]
\caption{Simplified illustration of a FAT and following cluster chains}
\centering
\includegraphics{figures/cluster_chain}
\end{figure}

After evaluating the cluster chain, the file system driver can access the contents of the clusters in the data area. To do this, the logical block address where a cluster starts can be computed as follows: ((cluster - 2) * sectors per cluster) + data area offset

\subsection{Directories and files}

Directories and files are located in the data area of a FAT32 file system. The exact location of the contents and which clusters correspond to the directory or file must be determined by a cluster chain from the FAT. A directory consists of multiple 32 byte entries describing the contents of the directory. The contents can either be other directories, so called sub directories or files. The root directory is always present on a FAT32 file system. The start cluster of the root directory is stored in the boot sector.

Files do not have a defined structure, unlike directories. The raw data the file consists of is located in the different clusters, just as it is. The only thing defined, is the order, which can be determined from the FAT.
\\\\
Figure \ref{figure:data_area} shows a simplified example of the data area. The root directory starts at cluster 2 and ends with cluster 6. There is also a file in the data area, consisting of cluster 3 and 5. In cluster 4 a sub directory is located consisting only of one cluster. The whole data area is separated into clusters with a certain size, containing either chunks of data of a directory or a file.

\begin{figure}[h!]
\caption{Simplified illustration of the content in the data area}
\centering
\includegraphics[scale=0.62]{figures/fat_data_area}
\label{figure:data_area}
\end{figure}

\subsubsection{Fat Directory Entry}

The following table describes the structure of a Fat Directory entry. Every entry, normally, represents either another (sub)directory or file. The root directory can also have a special entry not only describing files and other directories but an optional volume label which gives the volume a name. Remember that such a volume label could also be specified in the boot sector. Another special entry is the long file name entry, which is described later.

\begin{table}[!ht]
\caption{Fat Directory Entry, compare to: \cite{usb_ms_jan, fatgen103}}
\centering
\begin{tabular}{|l|l|l|p{8.5cm}|}
\hline\hline
\textbf{Name} & \textbf{Offset} & \textbf{Size} & \textbf{Description}\\ \hline
DIR\_Name & 0 & 11 & The short name of the directory or file. \\ \hline
DIR\_Attr & 11 & 1 & Attributes to determine if this entry describes a directory or a file, etc.. \\ \hline
DIR\_NTRes & 12 & 1 & Reserved. \\ \hline
DIR\_CrtTimeTenth & 13 & 1 & Timestamp which holds the tenth of a second when the file was created. The range os from 0 to 199. \\ \hline
DIR\_CrtTime & 14 & 2 & The time the file was created. \\ \hline
DIR\_CrtDate & 16 & 2 & The date the file was created. \\ \hline
DIR\_LstAccDate & 18 & 2 & The date the file was last accessed (read or write). \\ \hline
DIR\_FstClusHI & 20 & 2 & The higher two bytes of the entries start cluster. Unused if the entry is not a file. \\ \hline
DIR\_WrtTime & 22 & 2 & The time the file last modified (write). \\ \hline
DIR\_WrtDate & 24 & 2 & The date the file last modified (write). \\ \hline
DIR\_FstClusLO & 26 & 2 & The lower two bytes of the entries start cluster. Unused if the entry is not a file. \\ \hline
DIR\_FileSize & 26 & 4 & The length of a file in bytes. Unused if the entry is not a file. \\ \hline
\end{tabular}
\label{table:fat_dir_entry}
\end{table}

\subsubsection{Short name}

Every entry has a short name which is a human readable name. The name consists of eight characters for the file name and three optional characters for the file extension. Therefore it is also called 8.3 name. The period to separate name and extension is not stored in the short name. If a name does not need the whole eight characters the unused characters have to be padded with spaces (ASCII: 20h). The same applies for the extension. A short name has various limitations\cite{usb_ms_jan}:

\begin{itemize}
\item Each character is only eight bit (no unicode support)
\item It has to begin with a letter or a number
\item Every character is stored upper case
\item Other valid characters are: \$ \% $'$ -  \_ @ $\sim$ $`$ ! ( ) { } \^{} \# \&
\end{itemize}

If the first byte of the short name equals to E5h, then this directory entry is free and has been deleted. If the first byte equals to 00h, then this entry is also free, but there are not any following entries, looping through the entries can thus be stopped. In the first case it can happen that there are valid entries that follow. If the first byte equals to 05h, then the actual value of the first byte shall be E5h, which is a KANJI lead byte used in Japan. This is a workaround for avoiding the entry to be accidentally treated as free (deleted).

\subsubsection{Attributes}

\begin{table}[!ht]
\caption{Attributes of an entry, compare to: \cite{usb_ms_jan, fatgen103}}
\centering
\begin{tabular}{|l|l|p{9cm}|}
\hline\hline
\textbf{Name} & \textbf{Value}  & \textbf{Description}\\ \hline
ATTR\_READ\_ONLY & 01h & The file is read only and writing to it should fail. \\ \hline
ATTR\_HIDDEN & 02h & A hidden entry the user should only see when explicitly asking for it. \\ \hline
ATTR\_SYSTEM & 04h & A file from the operating system. \\ \hline
ATTR\_VOLUME\_ID & 08h & This entry is not a file and not a directory, it is the entry which stores the volume label. This can occur only in the root directory and only once. \\ \hline
ATTR\_DIRECTORY & 10h & Indicates that the entry describes a (sub)directory. \\ \hline
ATTR\_ARCHIVE & 20h & Value to help backup utilities to identify files that changed since the last backup. Should be set if a file has been changed. \\ \hline
ATTR\_LONG\_NAME & 0fh & Indicates that this entry is not a file or a directory but an entry which holds a long file name. \\ \hline
\end{tabular}
\label{table:fat_dir_entry_attr}
\end{table}

The last attribute in table \ref{table:fat_dir_entry_attr} stands for a long file name entry. Because of the limitations of the short name, Microsoft added support for long file names afterwards. To ensure backward compatibility they used some sort of work around to hide the long file names in normal directory entries. They are discussed later in detail.

If the volume id attribute is set, the short name is not actually the name of a file, it is the name of the volume. The volume name is shown in the Windows Explorer directly left of the drive letter. The volume label can have up to eleven characters, but there is now period between the eighth and the ninth character.

\subsubsection{Date and time fields}

In the directory entry there are many date and time fields, the following describes how the date and time is stored in these fields. Every date and time field consists of two bytes. 

\begin{table}[!ht]
\caption{Date format, compare to: \cite{usb_ms_jan, fatgen103}}
\centering
\begin{tabular}{|l|p{9cm}|}
\hline\hline
\textbf{Bits} & \textbf{Description}\\ \hline
0-4 & Day of month, range 1-31 \\ \hline
5-8 & Month, starting with 1 for January \\ \hline
9-15 & Count of years from 1980, range 0-127 corresponding to 1980-2107 \\ \hline
\end{tabular}
\label{table:fat_dir_entry_date}
\end{table}

\begin{table}[!ht]
\caption{Time format, compare to: \cite{usb_ms_jan, fatgen103}}
\centering
\begin{tabular}{|l|p{9cm}|}
\hline\hline
\textbf{Bits} & \textbf{Description} \\ \hline
0-4 & Count of seconds with a resolution of 2 seconds, range 0-29 meaning 0-58 seconds \\ \hline
5-10 & Minutes, range 0-59 \\ \hline
11-15 & Hours, range 0-23 \\ \hline
\end{tabular}
\label{table:fat_dir_entry_time}
\end{table}

\subsection{Subdirectories}

Every subdirectory has two special entries. The dot (.) and the dotdot (..) entry. The dot entry points the the current subdirectory itself. It has the same values as the entry for the subdirectory in the parent directory, ie. same date and time fields, same start cluster, etc. The dotdot entry points to the parent directory, but the date and time fields remain like in the subdirectory. The start cluster of the dotdot entry is the same as for the parent directory except if the parent directory is the root directory, then it is set to zero.

These two entries are the only exceptions where a short name starts with periods. The dot and dotdot entry must not have preceding long file name entries!

The root directory does not have these two special entries, this rule applies for subdirectories only!

\subsection{Long File Name entries}

As already mentioned the short name of a directory entry has several disadvantages. For that reason Microsoft afterwards faced this problem by adding long file name (LFN) entries. These entries "hide" in the normal directory entries and look like a hidden file with a start cluster of zero, indicating that the file does not occupy any space. Thus old implementations which do not support long file name entries can nevertheless work with the file system and the 8.3 names.

Long file names can have up to 255 characters and allow upper and lower case characters, leading, trailing and multiple periods and spaces in a file name\cite{usb_ms_jan}. Additionally these special characters are allowed\cite{fatgen103}: + , ; = [ ] 

Each entry with a normal short name, can have one or more long file name entries preceding the actual entry. A long file name entry can store up to 13 unicode characters, i.e. every character consists of two bytes instead of eight like in the short name.

\begin{table}[!ht]
\caption{Fat LFN Directory Entry, compare to: \cite{usb_ms_jan, fatgen103}}
\centering
\begin{tabular}{|l|l|l|p{8.5cm}|}
\hline\hline
\textbf{Name} & \textbf{Offset} & \textbf{Size} & \textbf{Description}\\ \hline
LDIR\_Ord & 0 & 1 & The number (order) of the entry in the sequence of long file name entries. \\ \hline
LDIR\_Name1 & 1 & 10 & The first five characters of the long file name. \\ \hline
LDIR\_Attr & 11 & 1 & Must be ATTR\_LONG\_NAME. \\ \hline
LDIR\_Type & 12 & 1 & Must be zero. \\ \hline
LDIR\_Chksum & 13 & 1 & The checksum of the short name associated with this long file name. \\ \hline
LDIR\_Name2& 14 & 12 & The next six characters of the long file name. \\ \hline
LDIR\_FstClusLO & 26 & 2 & Must be zero. Long file name entries do not have a start cluster. \\ \hline
LDIR\_Name3I & 28 & 4 & The last two characters of the long file name. \\ \hline
\end{tabular}
\label{table:fat_lfn_dir_entry}
\end{table}

The first byte is the number of the LFN entry. The first LFN entry before the short name entry, must have a value of one in that field. The second a two, and so on. If the LFN entry is the last entry, bit six of the LDIR\_Ord field has to be set to one, to indicate that it is the last one. There can be at most 20 LFN entries preceding a normal entry. The first LFN entry directly before the short name entry represents the begin of the long file name. That means the long file name is stored in "reverse order" on the disk. 

The long file entry should be terminated with a null character (0h) if there is enough space, and unused characters shall be padded with FFFFh.

\subsubsection{Checksum}

Every long file name entry needs a checksum of the corresponding short name. These checksum is calculated as follows:

\lstset{language=c}
\begin{lstlisting}[caption=Calculation of short name checksum \cite{fatgen103}, label=listing:fat_checksum]
//------------------------------------------------------------------
// ChkSum()
// Returns an unsigned byte checksum computed on an unsigned byte
// array. The array must be 11 bytes long and is assumed to contain
// a name stored in the format of a MS-DOS directory entry.
// Passed: pFcbName Pointer to an unsigned byte array assumed to be 11 bytes long.
// Returns: Sum An 8-bit unsigned checksum of the array pointed to by pFcbName.
//-------------------------------------------------------------------
unsigned char ChkSum (unsigned char *pFcbName)
{
    short FcbNameLen;
    unsigned char Sum;
    
    Sum = 0;
    for (FcbNameLen=11; FcbNameLen!=0; FcbNameLen--) {
        // NOTE: The operation is an unsigned char rotate right
        Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *pFcbName++;
    }
    return (Sum);
}
\end{lstlisting}

\subsubsection{Generating short names}

Every directory entry which has preceding long file name entries nevertheless needs a valid short name. There exist different algorithms for generating valid short names given a long file name. The algorithms mainly consist of removing illegal characters and convert them to underscores (\_), removing spaces and periods, truncating the long file name to eight and the extension if available to three characters. All characters must be converted to upper case and a tilde ($\sim$) must added if the file name was truncated, contained illegal characters or an entry with the same short name already exists in the directory. The official FAT specification\cite{fatgen103} and the book from Jan Axelson\cite{usb_ms_jan} describe two different approaches to generate valid 8.3 short names.