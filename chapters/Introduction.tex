\chapter{Introduction}
\label{chapter:Introduction}



Since Android 3.1 a lot of Android devices come with USB host support (USB on the go). That means a normal Android tablet or phone can not only act as a USB client when connected to a computer. It can also act as a USB host for periphals by powering the bus with the needed 5 Volt and changing into a USB host mode and enumerating connected USB devices\cite{android_usb_host}. Android currently supports interrupt, bulk and control transfers (isochronous transfers are currently unsupported). That means nearly every USB device can, theoretically, be used with an Android device (Webcams or Audio devices mostly use isochronous transfers and can thus not be used at the moment). The Android host API easily allows to communicate with connected USB devices, meaning you can write your own high level USB driver in Java.\\
Thus the idea of connecting a USB mass storage device like USB sticks or external HDDs is not that far away. Especially when you look at recent occurences where a lot of devices miss a slot for external SD-Cards and only offer a solid internal storage. Unfortunately the stock Android comes without support for USB storage devices. That means when you are connecting your mass storage device nothing will happen. You can not access the data via a file manager or something similiar. On rooted devices this is possible because the alternative Android ROMs provide support for it. But with the Android USB Host API it should also be possible to access such devices with out rooting the device and flashing an alternative ROM. The only thing you have to do is to implement the low level USB communication via eg. bulk transfers and the abtraction of directorys and files via a filesystem. This can of course also be done in Java and not only in plain C.\\
Currently there are two applications in the Google Play Store which allow accessing mass storage devices without root rights! First there is a plugin for the Total Commander called USB-Stick Plugin-TC. The plugin extends the Total Commander application by USB mass storage access. It currently supports FAT12, FAT16, FAT32 exFAT and NTFS (read only). There is a free trial version available. The second application is called Nexus Media Importer. It supports FAT16, FAT32 and NTFS (also read only). There is no free trial verson available. In general both apps support USB sticks, external HDDs and card readers.\\
The problem both applications have is that there is no solution to access the mass storage from other apps. That means all accessed data has to be cached and copied to the internal storage before any other app can access it. These limitations are annoying but it seems that they are impossible to overcome.\\
Both applications are proprietary and thus do not offer the ability to look into and change the source code. Therefore an open source Android Framework for accessing mass storage devices is developed in this bachelor thesis. The license is the very liberale Apache License, Version 2.0, Android is also licensed under.\\
Due to the same license it would be possible that Google integrates this solution into the official Android. Indeed there are some disadvantages which makes the integration unlikely. First all needed things, like filesystems (eg. FAT32) or the SCSI transparent command set, for mounting USB mass storage are already implemented in the underlying Linux kernel. Google just deactivated the support for it. Next with our solution only apps which use our framework can access USB storage devices. It would be much nicer if the conncected devices would be mounted in the normal unix filesystem like sd cards. For example under /mnt/usbstick0. This would make it possible for other apps easily access data from USB mass storage without extra changes to the application. Due to this I think that is very unlikely that Google will integrate this framework into the official Android!
 
\section{Basics about USB}

USB means universal serial bus interface is a serial bussystem to connect a computer with external devices. The first version was introduced by Intel and now the specification is done by the USB Implementers Forum (USB-IF). The USB-IF is a corporation founded by various companies which work non-profit on the USB specification. In USB there exists one USB host controller (eg. computer) which initiates the connection and comunication and multiple clients (slaves). The client only sends data when the host aks for it. The USB host ist responsible for powering the connected client, thus an external power source is only in some special cases necessary.

\subsection{Client device hierarchy}

A USB client can be structured in four different USB descriptors. The device, configuration, interface and endpoints.\\
The device descriptor represents the USB device as a hole device which is connected to the USB bus. This can be for example a loud speaker with volume control buttons.\\
The configuration descriptor represents the current state of the USB device. This can for example be standby or active.\\
A USB Interface descriptor describes every logical device which belongs to the USB device. Often USB devices consist of multiple logical device units. For example a loud speaker is the first logical device and the control buttons to adjust the volume are the second logical device.\\
Lastly there are the endpoint descriptors which represent unidirectional communication pipes. This is where the actual communication happens. The other descriptors are only to describe the USB device. Endpoints can be of type IN (device to host) or OUT (host to device). Additional tehre are four different types of endpoints to fit different requirements when communicating.\\

\subsection{Endpoints}

Every USB device has different requirements towards the underlying communication pipe. To satisfy the different needs the USB protocol offers four different types of communicaton (endpoints).\\
Control endpoints are used to configure the device and retrieve status information. These transfers are typically very small. Every device has a control endpoint called endpoint 0 which plays an important role at insertion time.\\
Interrupt transfers carry a small amount of data to the host everytime the host aks for it. This happens at a fixed rate resulting in a fixed and guarenteed bandwidth. These transfers are used by Human interface devices (eg. mouse, keyboard, gamepads) which need a low latency and a low paket size.\\
Next there are bulk endpoints. These are useful when the amount of data transferred varies often and happens infrequently. The remaining bandwidth the bus provides is used. Hence there is no guarantee on bandwith or latency. However bulk transfers offer consistent data transfers, meaning that no data is lost. Typically used for printers, network or mass storage devices. Everywhere where data loss is unacceptable and no guarenteed bandwith is needed.\\
Finally there are the isochronous transfers. They offer a guarenteed bandwith while resigning consistency. The guarenteed bandwith is mostly as fast as possible and valueable for real time transfers (eg. audio or video). Mostly these transfers are used for Webcams or Audio devices (eg. external audio cards/audio interfaces).\\

\subsection{USB on the go}

As already mentioned in the USB communication there is always a host (master) and a client (device). The host initates the communication and acts as a master. That means the client is not allowed to send data at every time, it can only send data when the host explicitly asks to do so! The client is only able to signal that it requires attention. Then the host must react and ask for receiving data. When connecting a smartphone or tablet to the computer the computer acts as the host and the smartphone as the client device. That means the smartphone normally acts as a client device and not as the USB host. In our constellation, however, it has obvisously to act as a host. \\
For that reason the USB-IF developed the USB on the go (USB OTG) featur in 2001. It is part of the USB 2.0 specification. This feature allows a USB device to act as a client or either a host depending on the present situation. To use the USB OTG mode a special USB OTG adapter is needed. This is necessary for two reasons. Apriori for signalling that the smartphone should now act as a host and not as usual as a client and secondly because most smartphones and tables do not provide a normal USB port of type A. Instead they offer a mini (older devices) or micro port of type A and B. 

\section{USB Mass storage class}

Most USB devices are very similiar. To reduce development effort and allow OS designers offering generic drivers for a great range of different devices a lot of device types are standardized. These different types are called classes in USB. There are for example standardizations for printers, USB hubs, Audio or Video Devices, Human Interface devices and mass storage devices. We will now concentrate on the mass storage class.\\
Every mass storage device has at least one interface descriptor with the class code 08h, which stands for the mass storage class. Note that the mass storage class is not defined in the device descriptor! The USB interface has exactly two endpoint descriptors. One IN endpoint to read from the device and one OUT endpoint to write to the device. Reading and writing in this case does not neccessarily mean reading or writing on the actual storage medium, but we will see that later on.\\
There are several sources regarding the mass storage class. It exists the bulk-only transport mechanism which is the most popular one. All newer devices follow these standard. The there is the Control/Bulk/Interrupt (CBI) standard and the UFI Command specification, which are no longer important. In the end the are some mechanisms to allow booting from removable media. We will concentrate on the bulk-only transport short BBB.

\subsection{Bulk-only Transport}

Unlike the name suggests there are two control requests in the BBB specification. The first one is a reset request to make the device becomming ready for the next command. The second is used to get the maximun LUN (Get Max LUN request). This requests tells about the number of standalone logical units the mass storage device supports.\\
Like saif before the interface class has to be set to 08h for the mass storage class. The subclass of the interface descriptor can have different values and specifies the supported protocols used to read and write data to the mass storage. Table \ref{table:subclass} gives an overview of the different protocol.

\begin{table}[ht]
\caption{Overview subclass protocols}
\centering
\begin{tabular}{|l|l|}
\hline\hline
01h & Reduced Block Coammnds (RBC) \\ \hline
02h & SFF-8020i, MMC-2 (ATAPI) (CD/DVD drives) \\ \hline
03h & QIC-157 (tape drives) \\ \hline
04h & USB Floppy Interface (UFI) \\ \hline
05h & FF-8070i (ATAPI removable rewritable media devices) \\ \hline
06h & SCSI transparent command set \\ \hline
\end{tabular}
\label{table:subclass}
\end{table}

For our purpose the SCSI transparent command set is the most important one, we will learn about it in detail in the next chapter. The RBC is not even implemented in Windows, but in the Linux kernel. The other protocols refer to other types of storage media we do not want to cover.

\subsection{SCSI transparent comand set}

Every SCSI command the host sends to the client is enclosed by a so called Command Block Wrapper (CBW). Sending this CBW is always the first thing when host and device are communicating. After that raw data can be transferred, depending on the command. Some commands do not need the data transfer phase. This data can either be from host to device or vice versa. In the last step the client device sends a Command Status Wrapper (CSW) to the host to inform about any failures or success.\\

The CWB is always 31 bytes long including the enclosing SCSI command. The host sends it through the OUT endpoint to the device. Following table \ref{table:cbw} illustrates the CBW:

\begin{table}[ht]
\caption{Command Block Wrapper}
\centering
\begin{tabular}{|l|l|p{9cm}|}
\hline\hline
\textbf{Field Name} & \textbf{Bits} & \textbf{Description}\\ \hline
dCBWSignature & 32 & Fixed value of 43425355h to identify the CBW. \\ \hline
dCBWTag & 32 & Corresponds to dCSWTag in CSW. \\ \hline
dCBWDataTransferLength & 32 & The number of bytes which will be sent by the host in the transfer phase or the number of bytes the host expects to receive in the transger phase. Depends on bmCBWFlags. \\ \hline
bmCBWFlags & 8 & If bit 7 is set to 0 the data transfer is from host to device, if it is set to 1 from device to host. All other bits are unused. \\ \hline
Reserved & 4 & - \\ \hline
bCBWLUN & 4 & The LUN the command is directed to. \\ \hline
Reserved & 3 & - \\ \hline
bCBWCBLength & 5 & The length of the actual SCSI command located in the CBWCB field. \\ \hline
CBWCB & 128 & The SCSI command the client shall execute. \\ \hline
\end{tabular}
\label{table:cbw}
\end{table}

The dCBWTag is useful to associate the CSW again with the CBW. The device uses the same value sotred in the dCBWTag in the dCSWTag of the CSW. If you have multiple CBWs sent and receive multiple CSWs then you can easily find out which CBW corresponds to which CSW.\\

What data is transferred and how we will see when discussing the different SCSI commands. For now we will just igonre it and have a closer look at the CSW. The CSW is always 13 bytes.

\begin{table}[ht]
\caption{Command Status Wrapper}
\centering
\begin{tabular}{|l|l|p{9cm}|}
\hline\hline
\textbf{Field Name} & \textbf{Bits} & \textbf{Description}\\ \hline
dCSWSignature & 32 & Fixed value of 53425355h to identify the CSW. \\ \hline
dCSWTag & 32 & Value of dCBWTag from the sent CBW. \\ \hline
dCSWDataResidue & 32 & This indicates the number bytes of the data phase the device has not yet processed. Should be 0 if all data has been processed. \\ \hline
bCSWStatus & 8 & 0 if command successfully passed, 1 if there was an error and 2 on a phase error. \\ \hline
\end{tabular}
\label{table:csw}
\end{table}

The dCSWDataResidue holds the difference between the dCBWDataTransferLength and the number of bytes the device either processed when the host sends data or the number of bytes the device already sent to the host. Mostly all data can be transferred in one data transer phase meaning dCSWDataResidue is mostly 0. \\
The bCSWStatus informs about the success of a SCSI command. If this field is 1, the host should issue a SCSI REQUEST SENSE command to get more information about what went wrong. More on this SCSI command later. If this value is 2 the host should perform a reset recovery. 
