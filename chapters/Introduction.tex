\chapter{Introduction}
\label{chapter:Introduction}



Since Android 3.1 a lot of Android devices come with USB host support (USB on the go). That means a normal Android tablet or phone can not only act as a USB client when connected to a computer. It can also act as a USB host for periphals by powering the bus with the needed 5 Volt and changing into a USB host mode and enumerating connected USB devices\cite{android_usb_host}. Android currently supports interrupt, bulk and control transfers\footnote{isochronous transfers are currently unsupported\cite{android_usb_constants}}. That means nearly every USB device can, theoretically, be used with an Android device\footnote{Webcams or Audio devices mostly use isochronous transfers and can thus not be used at the moment}. The Android host API easily allows to communicate with connected USB devices, meaning you can write your own high level USB driver in Java.

Thus the idea of connecting a USB mass storage device like USB sticks or external HDDs is not that far away. Especially when you look at recent occurences where a lot of devices miss a slot for external SD-Cards and only offer a solid internal storage. Unfortunately the stock Android comes without support for USB storage devices. That means when you are connecting your mass storage device nothing will happen. You can not access the data via a file manager or something similiar. On rooted devices this is possible because the alternative Android ROMs provide support for it. But with the Android USB Host API it should also be possible to access such devices with out rooting the device and flashing an alternative ROM. The only thing you have to do is to implement the low level USB communication via eg. bulk transfers and the abtraction of directorys and files via a filesystem. This can of course also be done in Java and not only in plain C.

Currently there are two applications in the Google Play Store which allow accessing mass storage devices without root rights! First there is a plugin for the Total Commander called USB-Stick Plugin-TC. The plugin extends the Total Commander application by USB mass storage access. It currently supports FAT12, FAT16, FAT32 exFAT and NTFS (read only). There is a free trial version available. The second application is called Nexus Media Importer. It supports FAT16, FAT32 and NTFS (also read only). There is no free trial verson available. In general both apps support USB sticks, external HDDs and card readers.

The problem both applications have is that there is no solution to access the mass storage from other apps. That means all accessed data has to be cached and copied to the internal storage before any other app can access it. These limitations are annoying but it seems that they are impossible to overcome.

Both applications are proprietary and thus do not offer the ability to look into and change the source code. Therefore an open source Android Framework for accessing mass storage devices is developed in this bachelor thesis. The license is the very liberale Apache License, Version 2.0, Android is also licensed under.

Due to the same license it would be possible that Google integrates this solution into the official Android. Indeed there are some disadvantages which makes the integration unlikely. First all needed things, like filesystems (eg. FAT32) or the SCSI transparent command set, for mounting USB mass storage are already implemented in the underlying Linux kernel. Google just deactivated the support for it. Next with our solution only apps which use our framework can access USB storage devices. It would be much nicer if the conncected devices would be mounted in the normal unix filesystem like sd cards. For example under /mnt/usbstick0. This would make it possible for other apps easily access data from USB mass storage without extra changes to the application. Due to this I think that is very unlikely that Google will integrate this framework into the official Android!
 
\chapter{Basics about USB}

USB means universal serial bus interface and is a serial bussystem to connect a computer with external devices. The first version was introduced by Intel and now the specification is done by the USB Implementers Forum (USB-IF). The USB-IF is a corporation founded by various companies which work non-profit on the USB specification. In USB there exists one USB host controller (eg. computer) which initiates the connection and comunication and multiple clients (slaves). The client only sends data when the host aks for it. The USB host ist responsible for powering the connected client, thus an external power source is only in some special cases necessary.

\section{Client device hierarchy}

A USB client can be structured in four different USB descriptors:

\begin{itemize}
\item Device
\item Configuration
\item Interface
\item Endpoint
\end{itemize}

The device descriptor represents the USB device as a hole device which is connected to the USB bus. This can be for example a loud speaker with volume control buttons.\\
The configuration descriptor represents the current state of the USB device. This can for example be standby or active.\\
An USB Interface descriptor describes every logical device which belongs to the USB device. Often USB devices consist of multiple logical device units. For example a loud speaker is the first logical device and the control buttons to adjust the volume are the second logical device.\\
Lastly there are the endpoint descriptors which represent unidirectional communication pipes. This is where the actual communication happens. The other descriptors are only to describe the USB device. Endpoints can be of type IN (device to host) or OUT (host to device). Additional tehre are four different types of endpoints to fit different requirements when communicating.\\

\section{Endpoints}

Every USB device has different requirements towards the underlying communication pipe. To satisfy the different needs the USB protocol offers four different types of communicaton (endpoints).

Control endpoints are used to configure the device and retrieve status information. These transfers are typically very small. Every device has a control endpoint called endpoint 0 which plays an important role at insertion time.

Interrupt transfers carry a small amount of data to the host everytime the host aks for it. This happens at a fixed rate resulting in a fixed and guarenteed bandwidth. These transfers are used by Human interface devices (eg. mouse, keyboard, gamepads) which need a low latency and a low paket size.

Next there are bulk endpoints. These are useful when the amount of data transferred varies often and happens infrequently. The remaining bandwidth the bus provides is used. Hence there is no guarantee on bandwith or latency. However bulk transfers offer consistent data transfers, meaning that no data is lost. Typically used for printers, network or mass storage devices. Everywhere where data loss is unacceptable and no guarenteed bandwith is needed.

Finally there are the isochronous transfers. They offer a guarenteed bandwith while resigning consistency. The guarenteed bandwith is mostly as fast as possible and valueable for real time transfers (eg. audio or video). Mostly these transfers are used for Webcams or Audio devices (eg. external audio cards/audio interfaces).

\section{USB on the go}

As already mentioned in the USB communication there is always a host (master) and a client (device). The host initates the communication and acts as a master. That means the client is not allowed to send data at anytime, it can only send data when the host explicitly asks to do so! The client is only able to signal that it requires attention. Then the host must react and ask for receiving data. When connecting a smartphone or tablet to the computer the computer acts as the host and the smartphone as the client device. That means the smartphone normally acts as a client device and not as the USB host. In our constellation, however, it has obvisously to act as a host. 

For that reason the USB-IF developed the USB on the go (USB OTG) featur in 2001. It is part of the USB 2.0 specification. This feature allows a USB device to act as a client or either a host depending on the present situation. To use the USB OTG mode a special USB OTG adapter is needed. This is necessary for two reasons. Apriori for signalling that the smartphone should now act as a host and not as usual as a client and secondly because most smartphones and tables do not provide a normal USB port of type A. Instead they offer a mini (older devices) or micro port of type A and B. 

\chapter{USB on Android}

As we already know with Android 3.1 Honeycomb Google added USB features. There are two different modes Android keeps under control. The already mentioned Host support and a special USB Accessory mode\cite{android_usb_accessory}. The Accessory Mode is special and only available on Android. It is supposed to develop for example audio docking stations where the dock is the USB host and powers the Android device. The Android device is the client and can for example charge itself and play music through the docking station. The USB Accessory mode is also backported to Android 2.3.4\cite{android_usb_accessory}. For our purpose we solely rely on the USB host functionality.

\section{USB Host API}

On Android there exist a few classes to enumerate, connect to and communicate with connected USB devices. Table \ref{table:host_api} gives an overview of the classes which can be found in the package \textit{android.hardware.usb}.

\begin{table}[ht]
\caption{USB host APIs \cite{android_usb_host}}
\centering
\begin{tabular}{|l|p{10cm}|}
\hline\hline
\textbf{Class} & \textbf{Description} \\ \hline
UsbManager & Allows you to enumerate and communicate with connected USB devices. \\ \hline
UsbDevice & Represents a connected USB device and contains methods to access its identifying information, interfaces, and endpoints. \\ \hline
UsbInterface & Represents an interface of a USB device, which defines a set of functionality for the device. A device can have one or more interfaces on which to communicate on. \\ \hline
UsbEndpoint & Represents an interface endpoint, which is a communication channel for this interface. An interface can have one or more endpoints, and usually has input and output endpoints for two-way communication with the device. \\ \hline
UsbDeviceConnection & Represents a connection to the device, which transfers data on endpoints. This class allows you to send data back and forth sychronously or asynchronously. \\ \hline
UsbRequest & Represents an asynchronous request to communicate with a device through a UsbDeviceConnection. \\ \hline
UsbConstants & Defines USB constants that correspond to definitions in linux/usb/ch9.h of the Linux kernel. \\ \hline
\end{tabular}
\label{table:host_api}
\end{table}

The UsbRequest class is only needed when communicating asynchronous\footnote{We pass on asynchronous communication in our implementation and stick to the UsbDeviceConnection}. The rough procedure of getting in touch with a USB device includes following steps:

\begin{enumerate}
\item Retrieve the desired UsbDevice via the UsbManager
\item Get the appropriate UsbInterface and UsbEndpoint
\item Begin the communication by opening an UsbDeviceConnection via the UsbEndpoint
\end{enumerate}

To understand the following sections you should have fundamental knowledge of Android programming. Basic things\footnote{These terms should not be foreign to you: Activity, Intent, PendingIntent, IntentFiler, Broadcast, BroadcastReceiver} will not be described in detail here. If you need an introduction in Android porgramming, please refer to the offical Android developer documentation\footnote{\url{http://developer.android.com}}.

\section{Enumerating devices}

To enumerate through all connected USB devices you have to get the UsbManager and loop through the device list. The device list is returned by the method getDeviceList() of the UsbManager.

\begin{lstlisting}[caption=Enumerating connected USB devices, label=listing:enumerate]
UsbManager usbManager = (UsbManager) context.getSystemService(Context.USB_SERVICE);
		
for(UsbDevice device : usbManager.getDeviceList().values()) {
	Log.i(TAG, "found usb device: " + device);
}
\end{lstlisting}

Accessing the UsbInterface and the UsbInterface is also straight forward. The UsbDevice has a method to get the interface and the UsbInterface has a method to get the endpoint count on the other hand. Both classes have a method to get the interface resp. endpoint at an integer index. Listing \ref{listing:interface_endpoint} illustreates the process.

\begin{lstlisting}[caption=Accessing UsbInterface and UsbEndpoint, label=listing:interface_endpoint]
UsbManager usbManager = (UsbManager) context.getSystemService(Context.USB_SERVICE);
		
for(UsbDevice device : usbManager.getDeviceList().values()) {
	Log.i(TAG, "found usb device: " + device);
	
	int interfaceCount = device.getInterfaceCount();
	for(int i = 0; i < interfaceCount; i++) {
		UsbInterface usbInterface = device.getInterface(i);
		Log.i(TAG, "found usb interface: " + usbInterface);
		
		int endpointCount = usbInterface.getEndpointCount();
		for(int j = 0; j < endpointCount; j++) {
			UsbEndpoint endpoint = usbInterface.getEndpoint(j);
			Log.i(TAG, "found usb endpoint: " + endpoint);
		}
	}
}
\end{lstlisting}

While looping through the devices you can easily check if any device fits your needs. UsbDevice and UsbInterface have methods to get the class, subclass and the protocol.The UsbEndpoint class has methods to get the type, the direction and other attributes of the corresponding endpoint. The UsbDevice also offers methods to get the vendor and product ID of the connected device.

\section{Requesting permission for communication}
\label{section:request_permission}

After discovering a suitable device Android requires the user to accept the communication between an application and the USB device first. To do that you have to explicitly request the permission to communicate with the USB device. A dialog then is shown to the user asking for permission where the user can click okay or cancel. For that the UsbManager offers a method called requestPermission which takes a UsbDevice and a PendingIntent as parameter. The PendingIntent in this case is a Broadcast which can be recevied via registering a BroadcastReceiver with a specific IntentFilter.

Listing \ref{listing:permission_broadcast} shows how a BroadcastReceiver for receiving notifications about the permission can look like. First the the intent action is validated, this step is only needed if the BroadcastReceiver should receive multiple different actions. In this example this is not the case. After that the UsbDevice can be accessed via the an extra of the intent. Another extra of the intent is the state of the permission. If it is granted the extra is true and it is okay to communicate with the device.

\begin{lstlisting}[caption=Permission BroadcastReceiver \cite{android_usb_host}, label=listing:permission_broadcast]
private static final String ACTION_USB_PERMISSION =
    "com.android.example.USB_PERMISSION";
private final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {

    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if(ACTION_USB_PERMISSION.equals(action)) {
            synchronized (this) {
                UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);

                if(intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                    if(device != null){
                      //call method to set up device communication
                   }
                } 
                else {
                    Log.d(TAG, "permission denied for device " + device);
                }
            }
        }
    }
};
\end{lstlisting}

The next step is to register this BroadcastReceiver that it can actually receive broadcasts from the system. This normally happens in the onCreate method of an Activity via the method registerReceiver which takes the BroadcastReceive (mUsbReceiver) and and IntentFilter as a parameter. The IntentFilter uses our ACTION\_USB\_PERMISSION string to filter out undesired actions.

\begin{lstlisting}[caption=Register the BroadcastReceiver \cite{android_usb_host}, label=listing:register_broadcast]
IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
registerReceiver(mUsbReceiver, filter);
\end{lstlisting}

The last step consists of requesting the permission with the help of the UsbManager:

\begin{lstlisting}[caption=Register the BroadcastReceiver \cite{android_usb_host}, label=listing:request_permission]
UsbDevice device;
...
mPermissionIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);
mUsbManager.requestPermission(device, mPermissionIntent);
\end{lstlisting}

\section{Communication}

After succeeding all neccessary steps to set up the device, finally, communicating is possible. To do so we have to open the desired device and retrieve an UsbDeviceConnection. The class UsbDeviceConnection offers a method to claim a certain UsbInterface. After that communication is possible voa the UsbDeviceConnection. It offers methods like bulkTransfer or controlTransfer.

\begin{lstlisting}[caption=Communicating with a connected device \cite{android_usb_host}, label=listing:communication]
private Byte[] bytes
private static int TIMEOUT = 0;
private boolean forceClaim = true;
...
UsbInterface intf = device.getInterface(0);
UsbEndpoint endpoint = intf.getEndpoint(0);
UsbDeviceConnection connection = mUsbManager.openDevice(device); 
connection.claimInterface(intf, forceClaim);
connection.bulkTransfer(endpoint, bytes, bytes.length, TIMEOUT); //do in another thread
\end{lstlisting}

Listing \ref{listing:communication} above uses, for simplicity reasons, the first interface and enpoint. Normally the endpoint to communicate with should be chosen wisely by examing for example the interface class, or the vendor ID of the device. A control transfer would look like anaolgous.

\section{Tearing down the communication}

When the communication between the Android App and the USB device is done, the communication has to be shut down. This is done by releasing the interface and closing the connection. Listing \ref{listing:closing_communication} gives a hint about how to do that.

\begin{lstlisting}[caption=Closing communication, label=listing:closing_communication]
public void close() {
	Log.d(TAG, "close device");
	boolean release = deviceConnection.releaseInterface(usbInterface);
	if(!release) {
		Log.e(TAG, "could not release interface!");
	}
	deviceConnection.close();
}
\end{lstlisting}

\section{Listening to attach and detech events}

Android not only allows enumerating connected devices, an application can also register for attach and detach events of USB devices. The application then gets notified whenever a USB device is (dis)connceted to the Android device. There are two different solutions to do that. First one is via BroadcastReceiver, the second one via the AndroidManifest.xml file. The second solution has the advantage that the application gets notified even if it is not started before.

\subsection{Via BroadcastReceiver}

\begin{lstlisting}[caption=Attach and detach notification of USB devices via BroadcastReceivers, label=listing:attach_broadcast]
BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction(); 

      if (UsbManager.ACTION_USB_DEVICE_ATTACHED.equals(action)) {
            UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
            if (device != null) {
                // call your method that sets up and initiates communication with the device
            }
        }

      if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
            UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
            if (device != null) {
                // call your method that cleans up and closes communication with the device
            }
        }
    }
};
\end{lstlisting}

To use this BroadcastReceiver register it in your Activity or Service with the corresponding IntentFilter like this:

\begin{lstlisting}[caption=Register the BroadcastReceiver with the desired actions, label=listing:attach_register]
IntentFilter filter = new IntentFilter();
filter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);
filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
registerReceiver(mUsbReceiver, filter);
\end{lstlisting}

\subsection{Via AndroidManifest.xml}

If an application wants to get notified about of an atatched USB device this can also happen in the AndroidManifest.xml. This has the advantage that the application does not have to be started before. In fact it will be started when a desired USB device is connected. The user is then asked if he wants to start the application which can handle the attached device. The next benefit is that the step of requesting described in \ref{section:request_permission} the permission is not required because the user already gave his consent by allowing the application to start.

As a plus you can specify a device filter which allows your application to get notified only if an appropirate device was attached. You can specify following attributes\cite{android_usb_host}:

\begin{itemize}
\item Vendor ID
\item Product ID
\item Class
\item Subclass
\item Protocol (device or interface)
\end{itemize}

Here is an example how a device filter could look like:

\lstset{language=XML}
\begin{lstlisting}[caption=Example device filter\cite{android_usb_host}, label=listing:device_filter]
<?xml version="1.0" encoding="utf-8"?>

<resources>
    <usb-device vendor-id="1234" product-id="5678" class="255" subclass="66" protocol="1" />
</resources>
\end{lstlisting}

This resource file should be located at \textit{res/xml/device\_filter.xml} in the project directory\cite{android_usb_host}. This device filter can then be used in the AndroidManifest.xml, which shows Listing \ref{listing:manifest}.

\begin{lstlisting}[caption=AndroidManifest.xml\cite{android_usb_host}, label=listing:manifest]
<manifest ...>
    <uses-feature android:name="android.hardware.usb.host" />
    <uses-sdk android:minSdkVersion="12" />
    ...
    <application>
        <activity ...>
            ...
            <intent-filter>
                <action android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" />
            </intent-filter>

            <meta-data android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED"
                android:resource="@xml/device_filter" />
        </activity>
    </application>
</manifest>
\end{lstlisting}

The intent filter for the action uses again the USB\_DEVICE\_ATTACHED string like when using a BroadcastReceiver. But note that this time no broadcast is sent, an activity is started. The minimun sdk version is set to 12 here, because on lower API levels the USB API is not available. The manifest also contains a uses-feature entry, because not all Android devices guarantee to support the USB host feature\cite{android_usb_host}.

\chapter{USB Mass storage class}

Most USB devices are very similiar. To reduce development effort and allow OS designers offering generic drivers for a great range of different devices a lot of device types are standardized. These different types are called classes in USB. There are for example standardizations for printers, USB hubs, Audio or Video Devices, Human Interface devices and mass storage devices. We will now concentrate on the mass storage class.

Every mass storage device has at least one interface descriptor with the class code 08h, which stands for the mass storage class. Note that the mass storage class is not defined in the device descriptor! The USB interface has exactly two endpoint descriptors. One IN endpoint to read from the device and one OUT endpoint to write to the device. Reading and writing in this case does not neccessarily mean reading or writing on the actual storage medium, but we will see that later on.

There are several sources regarding the mass storage class. It exists the bulk-only transport mechanism which is the most popular one. All newer devices follow these standard. The there is the Control/Bulk/Interrupt (CBI) standard and the UFI Command specification, which are no longer important. In the end the are some mechanisms to allow booting from removable media. We will concentrate on the bulk-only transport short BBB.

\section{Bulk-only Transport}

Unlike the name suggests there are two control requests in the BBB specification. The first one is a reset request to make the device becomming ready for the next command. The second is used to get the maximun LUN (Get Max LUN request). This requests tells about the number of standalone logical units the mass storage device supports.

Like said before the interface class has to be set to 08h for the mass storage class. The subclass of the interface descriptor can have different values and specifies the supported protocols used to read and write data to the mass storage. Table \ref{table:subclass} gives an overview of the different protocol.

\begin{table}[ht]
\caption{Overview subclass protocols \cite{usb_ms_jan}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
01h & Reduced Block Coammnds (RBC) \\ \hline
02h & SFF-8020i, MMC-2 (ATAPI) (CD/DVD drives) \\ \hline
03h & QIC-157 (tape drives) \\ \hline
04h & USB Floppy Interface (UFI) \\ \hline
05h & FF-8070i (ATAPI removable rewritable media devices) \\ \hline
06h & SCSI transparent command set \\ \hline
\end{tabular}
\label{table:subclass}
\end{table}

For our purpose the SCSI transparent command set is the most important one, we will learn about it in detail in the next chapter. The RBC is not even implemented in Windows, but in the Linux kernel\cite{usb_ms_jan}. The other protocols refer to other types of storage media we do not want to cover.

\section{SCSI transparent comand set}

Every SCSI command the host sends to the client is enclosed by a so called Command Block Wrapper (CBW). Sending this CBW is always the first thing when host and device are communicating. After that raw data can be transferred, depending on the command. Some commands do not need the data transfer phase. This data can either be from host to device or vice versa. In the last step the client device sends a Command Status Wrapper (CSW) to the host to inform about any failures or success.

The CWB is always 31 bytes long including the enclosing SCSI command. The host sends it through the OUT endpoint to the device. Following table \ref{table:cbw} illustrates the CBW:

\begin{table}[ht]
\caption{Command Block Wrapper \cite{usb_ms_jan}}
\centering
\begin{tabular}{|l|l|p{9cm}|}
\hline\hline
\textbf{Field Name} & \textbf{Bits} & \textbf{Description}\\ \hline
dCBWSignature & 32 & Fixed value of 43425355h to identify the CBW. \\ \hline
dCBWTag & 32 & Corresponds to dCSWTag in CSW. \\ \hline
dCBWDataTransferLength & 32 & The number of bytes which will be sent by the host in the transfer phase or the number of bytes the host expects to receive in the transger phase. Depends on bmCBWFlags. \\ \hline
bmCBWFlags & 8 & If bit 7 is set to 0 the data transfer is from host to device, if it is set to 1 from device to host. All other bits are unused. \\ \hline
Reserved & 4 & - \\ \hline
bCBWLUN & 4 & The LUN the command is directed to. \\ \hline
Reserved & 3 & - \\ \hline
bCBWCBLength & 5 & The length of the actual SCSI command located in the CBWCB field. \\ \hline
CBWCB & 128 & The SCSI command the client shall execute. \\ \hline
\end{tabular}
\label{table:cbw}
\end{table}

The dCBWTag is useful to associate the CSW again with the CBW. The device uses the same value sotred in the dCBWTag in the dCSWTag of the CSW. If you have multiple CBWs sent and receive multiple CSWs then you can easily find out which CBW corresponds to which CSW.

What data is transferred and how we will see when discussing the different SCSI commands. For now we will just ignore it and have a closer look at the CSW. The CSW is always 13 bytes.

\begin{table}[ht]
\caption{Command Status Wrapper \cite{usb_ms_jan}}
\centering
\begin{tabular}{|l|l|p{9cm}|}
\hline\hline
\textbf{Field Name} & \textbf{Bits} & \textbf{Description}\\ \hline
dCSWSignature & 32 & Fixed value of 53425355h to identify the CSW. \\ \hline
dCSWTag & 32 & Value of dCBWTag from the sent CBW. \\ \hline
dCSWDataResidue & 32 & This indicates the number bytes of the data phase the device has not yet processed. Should be 0 if all data has been processed. \\ \hline
bCSWStatus & 8 & 0 if command successfully passed, 1 if there was an error and 2 on a phase error. \\ \hline
\end{tabular}
\label{table:csw}
\end{table}

The dCSWDataResidue holds the difference between the dCBWDataTransferLength and the number of bytes the device either processed when the host sends data or the number of bytes the device already sent to the host. Mostly all data can be transferred in one data transer phase meaning dCSWDataResidue is mostly 0.

The bCSWStatus informs about the success of a SCSI command. If this field is 1, the host should issue a SCSI REQUEST SENSE command to get more information about what went wrong\cite{usb_ms_jan}. More on this SCSI command later. If this value is 2 the host should perform a reset recovery. The reset consists of a bulk-only mass storage reset, which is one of the class specific commands and a Clear Feature HALT on the IN and OUT endpoint\cite{usb_ms_jan, usb_mass_bulk}.

The fields in the CBW and CSW are all serialized in little endian style.

\section{SCSI Commands}

The Small Computer System Interface (SCSI) is a standard for connecting and communicating a computer with peripheral devices. It is most commonly used for hard disks and other sotrage devices, but it can also used for example for scanners\cite{wiki_scsi}. SCSI commands are used to get general information about the connected storage device, but also for reading and writing data from and to it. The USB mass storage class also uses this well established standard.

The are a lot of different SCSI commands and not every device supports every command. To determine which commands a device supports, the host issues a SCSI INQUIRY command. Every device has to support this command and deliver a meaningful response to it. The device discloses with the information included in the response which commands are supported, ie. which standardization it follows. In practise the most common used commands are these\cite{usb_ms_jan}:

\begin{itemize}
\item INQUIRY
\item READ CAPACITY(10)
\item READ(10)
\item REQUEST SENSE
\item TEST UNIT READY
\item WRITE(10)
\end{itemize}

Every device should support at minimum these commands! SCSI commands use the big endian style for storing fields bigger than one byte. Every SCSI command starts with the operation code, also called OPCODE (one byte), which identifies the command. The following data then depends on the specific command. The ten after some commands describes the length of the command. There are for example different READ commands, READ(6), READ(10), READ(12), READ(16) and READ(32)\cite{scsi_seagate}. These commands all differ in their length. The READ(32) command is the biggest command. This is needed because in the READ(6) command, the logical block address field which is used to address a block is only 16 bit. However devices with a big storage cannot use this command because some parts of the memory cannot be addressed because their address would exceed the range of a 16 bit value. Thus in the READ(10) command, which is the most commonly used, the address field is 32 bit.

\subsection{INQUIRY}

As already mentioned the INQUIRY command is used to get general infomration about the connected strage device. A host should issue this command at first to determine which commands are supported by the device. The response is the transferred in the data phase between sending the CBW which includes the INQUIRY command and receiving the CSW. The direction of the data phase is from the device to the computer.

\begin{table}[ht]
\caption{INQUIRY command, compare to: \cite{scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation code (12h) \\ \hline
1 & Bit 0: EVPD, Bit 1: Obsolete, Bit 2-7: Reserved\\ \hline
2 & Page Code \\ \hline
3 & Allocation Length MSB \\ \hline
4 & Allocation Length LSB \\ \hline
5 & Control \\ \hline
\end{tabular}
\label{table:inquiry}
\end{table}

The most important fields in the INQUIRY command are the operation code and the allocation length. The allocation length tells the storage device how many bytes the host has allocated for the INQUIRY response. The device then replies with an answer at most as big as the allocation length. The allocation field should be at leasst five (bytes). The EVPD\footnote{Enable Vital Product Data} and the page code are used to get more information about the vital product data. If the EVPD bit is set to one, the device should return the part of the vital product data specified in the field page code. If the EVPD bit is set to zero only the standard INQUIRY data shall be returned\cite{scsi_seagate}. We will only look at the latter case.

The Allocation Length field and the Control field are commonly used fields which occur in various SCSI commands\cite{scsi_seagate}.

The response to the standard INQUIRY request shall contain 36 bytes\cite{scsi_seagate}. Bytes 5 until N consists of fields we will not discuss, because they are less important and vendor sepcific information.

\begin{table}[ht]
\caption{Standard INQUIRY data, compare to: \cite{usb_ms_jan, scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Bit 0-4: Peripheral device type, Bit 5-7: Peripheral Qualifier \\ \hline
1 & Bit 0-6: Reserved, Bit 7: RMB \\ \hline
2 & Version \\ \hline
3 & Bit 0-3: Response data format, Bit 4: HISUP, Bit 5: NORMACA Bit 6,7: Obsolete \\ \hline
4 & Additional length (N-4) \\ \hline
5-N & ... \\ \hline
\end{tabular}
\label{table:inquiry_data}
\end{table}

The peripheral device type shall always be zero. This indicatdes that a peripheral device is connected to the logical unit. The peripheral qualifier describes the connected device. If this field is set to zero the connected device is a direct access block device. A value of two means a printer device and a value of five means a CD or DVD drive\cite{usb_ms_jan, scsi_seagate}. In our case this value shall also always be zero for the direct access block device.

The RMB bit indicates if the device is removable or not. Zero indicates a non removable device and one a removable device. USB flash drives are removable devices, but they have a fixed media unlike card readers. But Microsoft suggests that flash drives declare they habe removable media, and thus some flash drives do this\cite{usb_ms_jan}.

The Version field indicates which standard of the SPC (SCSI Primary commands) the device follows. If the value is zero the device does not comply to any standard. If the value is three or four, the device complies to the SPC or SPC-2 standard\cite{usb_ms_jan, scsi_seagate}.

The Response Data Format field must equal to two, because values lower than two are obsolete and values bigger than two reserved\cite{scsi_seagate}.

The additional length provides information about how many bytes are remaining in the response. The additional data is not important for us at the moment.

\subsection{TEST UNIT READY}

This command tests if the storage device is ready to use. This command does not have a data phase. If the device is ready to use the CSW status is set to successful and if not to command failed. In the latter case the host should issue a SCSI REQUEST SENSE, to get information about what is wrong. When the device has removable media, this command can be used to check if a media is currently present\cite{usb_ms_jan}.

\begin{table}[ht]
\caption{TEST UNIT READY command\cite{scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation Code (00h)\\ \hline
1-4 & Reserved \\ \hline
5 & Control \\ \hline
\end{tabular}
\label{table:unit_ready}
\end{table}

\subsection{READ CAPACITY}

The READ CAPCITY command is used to determine the sotrage space of a device. The device tells the host the logical block address (LBA) of the last block and the size in bytes of one single block. The total number of blocks is then LBA of the last block address plus one. The direction of the data phase is from the device to the computer.

\begin{table}[ht]
\caption{READ CAPACITY(10) command\cite{scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0 & Operation Code (25h)\\ \hline
1 & Bit 0: Obsolete, Bit 1-7: Reserved \\ \hline
2-5 & Logical Block Address (Byte 2: MSB, Byte 5: LSB) \\ \hline
6,7 & Reserved \\ \hline
8 & Bit 0: PMI, Bit 1-7: Reserved \\ \hline
9 & Control \\ \hline
\end{tabular}
\label{table:read_capacity}
\end{table}

If the PMI (parial media indicator) bit is set to zero, the logical block addres also must be set to zero. The device then returns information of the last logical block. If the PMI bit is set to one, the Seagte manual on SCSI commands says: "A PMI bit set to one specifies that the device server return information on the last logical block after that specified in the LOGICAL BLOCK ADDRESS field before a substantial vendorspecific delay in data transfer may be encountered."\cite{scsi_seagate}

The response transferred in the data phase looks like this:

\begin{table}[ht]
\caption{READ CAPACITY(10) command, compare to \cite{usb_ms_jan, scsi_seagate}}
\centering
\begin{tabular}{|l|l|}
\hline\hline
\textbf{Byte} & \textbf{Description}\\ \hline
0-3 & Last Logical Block Address (Byte 0: MSB, Byte 3: LSB)\\ \hline
4-7 & Block length in bytes (Byte 4: MSB, Byte 7: LSB) \\ \hline
\end{tabular}
\label{table:read_capacity_response}
\end{table}